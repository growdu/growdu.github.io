<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式一致性协议</title>
      <link href="/2023/02/14/fen-bu-shi-yi-zhi-xing-xie-yi/"/>
      <url>/2023/02/14/fen-bu-shi-yi-zhi-xing-xie-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式一致性协议"><a href="#分布式一致性协议" class="headerlink" title="分布式一致性协议"></a>分布式一致性协议</h1><p>当前业界主流的分布式一致性协议主要有如下几种：</p><ul><li><p>totem协议（简单即有效）</p><p>totem协议，全称是The Totem Single-Ring Ordering and Membership Protocol，是一个基于令牌环的分布式一致性算法。corosync基于totem协议实现。</p></li><li><p>paxos协议（二阶段提交）</p><ul><li><p>raft协议（二阶段提交，基于paxos协议完善和改进）</p><p>Raft协议就是Paxos的衍生，etcd基于raft协议实现。</p></li><li><p>zab协议（二阶段提交）</p><p>ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复和原子广播协议。</p></li></ul></li></ul><h2 id="totem协议"><a href="#totem协议" class="headerlink" title="totem协议"></a>totem协议</h2><blockquote><p>totem协议，全称是The Totem Single-Ring Ordering and Membership Protocol，是一个基于令牌环的分布式一致性算法。一个令牌在集群节点之间传递，拿到令牌的节点才能够发消息，消息通过UDP广播发送。所以，totem只适合在局域网里的小集群使用，这种情况下，这个算法性能还算高的。从CAP来说，totem具有强一致性，但几乎没有分区容错性，在网络出现分区时，totem会脑裂，当网络恢复时，会造成消息丢失。</p><p>在多个节点组成的集群中，totem实现让一个节点发送消息，其它所有节点都能全部收到，并且有序的提交给上层应用。</p><p>说起totem协议，最简单的形象就是，他将多个节点组成一个令牌环。多个节点手拉手形成一个圈，大家依次的传递token。只有获取到token的节点才有发送消息的权利。简单有效的解决了在分布式系统中各个节点的同步问题，因为只有一个节点会在一个时刻发送消息，不会出现冲突。当然，如果有节点发生意外时，令牌环就会断掉，此时大家不能够通信，而是重新组建出一个新的令牌环。</p><p>totem的节点有四个状态，也是组建集群的4个阶段。</p><ul><li>Gather阶段：<br>这个阶段用于每个节点向外界广播自己的存在并收集其它节点的存在</li><li>Commit阶段：<br>这个阶段会产生一个代表节点，该节点向其它所有节点收集信息，并将收集的信息传递给其它所有节点，用于后续阶段</li><li>Recovery阶段：<br>这个阶段用于新旧集群交替时，旧集群成员用新集群传递旧集群的消息，使旧集群成员达到所有节点消息全部有序提交到上层</li><li>Operational阶段：<br>这个阶段是集群组建完成正常工作的状态，这个状态一个节点发送的消息其它节点都会全部有序提交给上层</li></ul><h3 id="通信方式。"><a href="#通信方式。" class="headerlink" title="通信方式。"></a>通信方式。</h3><ul><li>当集群有节点要发起通信时，需要等待token。</li><li>当拿到token后，先广播这次需要发送的数据，然后传递token来确认所有人都接收到消息。</li><li>如果确认成功，释放token。</li></ul><h3 id="节点的加入和退出。"><a href="#节点的加入和退出。" class="headerlink" title="节点的加入和退出。"></a>节点的加入和退出。</h3><ul><li>当集群中有节点加入时，加入的节点广播一个加入信息，所有人都开始广播自己的信息，当所有人都获得同伴信息，开始由id最小的人提交一个token，交由所有节点确认。</li><li>如果都确认后，则节点正式加入，开始正常运行。</li><li>当集群有节点退出时，由于令牌环断链，触发token超时，则同样开始广播信息，然后由最小id提交token，经过确认后恢复正常。</li></ul></blockquote><h2 id="raft协议"><a href="#raft协议" class="headerlink" title="raft协议"></a>raft协议</h2><blockquote><p>Paxos 算法的描述偏学术化，缺失了很多细节，无法直接应用于工程领域。实际工程应用中的分布式算法大多是 Paxos 的变种，Raft协议就是Paxos的简化。</p><p>RAFT算法分为两个阶段：Leader选举，日志复制。也有三种角色，分别为：</p><ol><li><strong>Leader（领导者）</strong>：负责发送要进行共识的数据，如果客户端发送的数据不是发送到Leader而是其他角色，其他角色会进行转发至Leader。</li><li><strong>Follower（追随者）</strong>：参与共识的角色</li><li><strong>Candidate（候选者）</strong>：如果Follower没有收到Leader的心跳响应超过150——300ms，会进行Leader选举</li></ol><p>正常运行的情况下，会有一个Leader，其他全为Follower，Follower只会响应Leader和Candidate的请求，而客户端的请求则全部由Leader处理，即使有客户端请求了一个Follower也会将请求重定向到Leader。Candidate代表候选人，出现在选举Leader阶段，选举成功后Candidate将会成为新的Leader。</p><p>Raft 将一致性问题分解为 3 个独立的子问题：</p><ul><li>Leader 选举Election：Leader 进程失效后能够自动选举出一个新的 Leader</li><li>日志复制Replication：Leader 保证其他节点的日志与其保持一致</li><li>状态安全Safety：Leader 保证状态机执行指令的顺序与内容完全一致</li></ul><h3 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h3><ul><li>所有节点初始状态为Follower状态，此时没有Leader，肯定会与Leader的心跳超时（一般150——300ms，随机的，这样就是想谁先发出竞选，谁当选leader），此时Candidate就会发出leader竞选给其他节点（大家快选我啊，leader挂掉了）；其他节点收到竞选请求，会响应同意，当一个Candidate收到大多数（n&#x2F;2 + 1）节点的回复，就成为leader。然后与Candidate保持心跳连接。Raft有个Term（任期）的概念，只有在发生Leader选举阶段，term+1，表示新的leader产生，挂掉的节点，或者挂掉的leader重启后，会发现自己的term小于最新的，此时就会切换到日志复制，去同步之前丢失的消息。</li><li>如果同时有多个Candidate发出竞选，并且都没有获得大多数投票，会一直进行竞选，直到选出leader</li></ul><h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><ul><li>leader收到客户端或者其他节点转发过来需要共识的值，会跟随心跳一起广播给其他节点，进行写入</li><li>其他节点写入后响应成功给leader，当leader收到大多数的follower响应的成功，发出commit命令</li><li>其他节点收到commit后，进行事务提交，响应成功为leader，leader收到大多数的commit成功，Raft完成</li></ul></blockquote><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><blockquote><p>Zookeeper是一个为分布式应用提供高效且可靠的分布式协调服务。在解决分布式一致性方面，Zookeeper并没有使用Paxos，而是采用了ZAB协议。</p><p>ZAB协议基本与Raft相同，都是Multi Paxos的衍生。ZAB与Raft在一些名词的叫法上有区别：如ZAB将某一个Leader的周期称为epoch，而Raft则称之为term。在实现上也有些许不同：Raft为了保证日志连续性，心跳方向为Leader至Follower，ZAB则相反。</p><h3 id="消息广播模式"><a href="#消息广播模式" class="headerlink" title="消息广播模式"></a>消息广播模式</h3><p>ZAB协议的消息广播过程使用的是一个原子广播协议，类似一个2PC<strong>二阶段提交过程</strong>。</p><ol><li>Leader将客户端的request转化成一个Proposal（提议）；</li><li>Leader为每一个Follower准备了一个FIFO队列，并把Proposal发送到队列上；</li><li>Leader若收到follower的半数以上ACK反馈；</li><li>Leader向所有的follower发送commit。</li></ol><h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>ZAB 定义了 2 个原则：</p><ol><li><p>ZAB 协议确保那些已经在 Leader 提交的事务最终会被所有服务器提交。</p></li><li><p>ZAB 协议确保丢弃那些只在 Leader 提出&#x2F;复制，但没有提交的事务。</p></li></ol><p>所以，ZAB 设计了下面这样一个选举算法：<strong>能够确保提交已经被 Leader 提交的事务，同时丢弃已经被跳过的事务。</strong>针对这个要求，如果让 Leader 选举算法能够保证新选举出来的 Leader 服务器拥有集群中所有机器编号（即 ZXID最大）的事务，那么就能够保证这个新选举出来的 Leader 一定具有所有已经提交的提案。</p></blockquote><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ol><li><a href="https://blog.csdn.net/zancijun1666/article/details/83512038">https://blog.csdn.net/zancijun1666/article/details/83512038</a></li><li><a href="https://blog.csdn.net/cloudresearch/article/details/23127985">https://blog.csdn.net/cloudresearch/article/details/23127985</a></li><li><a href="https://blog.csdn.net/TJtulong/article/details/106510970">https://blog.csdn.net/TJtulong/article/details/106510970</a></li><li><a href="https://blog.csdn.net/TJtulong/article/details/106510970">https://blog.csdn.net/TJtulong/article/details/106510970</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> 分布式 </tag>
            
            <tag> totem </tag>
            
            <tag> raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用分布式解决方案</title>
      <link href="/2023/02/14/chang-yong-fen-bu-shi-jie-jue-fang-an/"/>
      <url>/2023/02/14/chang-yong-fen-bu-shi-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h1 id="常用分布式解决方案"><a href="#常用分布式解决方案" class="headerlink" title="常用分布式解决方案"></a>常用分布式解决方案</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="集中式存储"><a href="#集中式存储" class="headerlink" title="集中式存储"></a>集中式存储</h3><blockquote><p>传统的存储也称为集中式存储， 从概念上可以看出来是具有集中性的，也就是整个存储是集中在一个系统中的，但集中式存储并不是一个单独的设备，是集中在一套系统当中的多个设备。集中式存储 最大的特点是有一个统一的入口，所有数据都要经过统一的入口。</p></blockquote><h3 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h3><blockquote><p>分布式存储最早是由谷歌提出的，其目的是通过廉价的服务器来提供使用与大规模，高并发场景下的 Web 访问问题。它 采用可扩展的系统结构，利用多台存储服务器分担存储负荷，利用位置服务器定位存储信息，它不但提高了系统的可靠性、可用性和存取效率，还易于扩展。</p><p>分布式存储包含的种类繁多，除了传统意义上的分布式文件系统、分布式块存储和分布式对象存储外，还包括分布式数据库和分布式缓存等，但其中架构无外乎于三种:</p><ul><li><p><strong>中间控制节点架构</strong></p><p>以 HDFS ( Hadoop Distribution File System )为代表的架构是典型的代表。在这种架构中，一部分节点 NameNode 是存放管理数据(元数据)，另一部分节点 DataNode 存放业务数据，这种类型的服务器负责管理具体数据。这种架构就像公司的层次组织架构， namenode 就如同老板，只管理下属的经理( datanode )，而下属的经理，而经理们来管理节点下本地盘上的数据。</p><p>在该架构中 NameNode 通常是主备部署( Secondary NameNode )，而 DataNode 则是由大量节点构成一个集群。由于元数据的访问频度和访问量相对数据都要小很多，因此 NameNode 通常不会成为性能瓶颈，而 DataNode 集群中的数据可以有副本，既可以保证高可用性，可以分散客户端的请求。因此，通过这种分布式存储架构可以通过横向扩展 datanode 的数量来增加承载能力，也即实现了动态横向扩展的能力。</p></li><li><p><strong>完全无中心架构 – 计算模式</strong></p></li></ul><p>  以 Ceph 为代表的架构是其典型的代表。在该架构中与 HDFS 不同的地方在于该架构中没有中心节点。客户端是通过一个设备映射关系 计算出来 其写入数据的位置，这样客户端可以直接与存储节点通信，从而避免中心节点的性能瓶颈。</p><ul><li><p><strong>完全无中心架构 – 一致性哈希</strong></p><p>以 Ceph 为代表的架构是其典型的代表。在该架构中与 HDFS 不同的地方在于该架构中没有中心节点。客户端是通过一个设备映射关系 计算出来 其写入数据的位置，这样客户端可以直接与存储节点通信，从而避免中心节点的性能瓶颈。</p></li></ul></blockquote><h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><h3 id="分布式一致性问题"><a href="#分布式一致性问题" class="headerlink" title="分布式一致性问题"></a>分布式一致性问题</h3><blockquote><p>分布式系统中要解决的一个非常重要的问题就是数据的复制，所谓分布式一致性的问题，就是指在分布式环境中引入数据复制机制后，不同数据节点之间可能会出现的、且无法依靠计算机应用程序自身解决的数据不一致的情况。</p><p>简单来说，数据一致性就是指在对一个副本数据进行变更的时候，必须确保也能够更新其它的副本，否则不同副本之间的数据将出现不一致。</p><ul><li><p>强一致性：这种一致性级别是最符合用户直觉的，它要求系统写入的是什么，读出来的也要是什么，用户体验好，但实现起来往往对系统的性能影响较大；</p></li><li><p>弱一致性：这种一致性级别约束了系统在写入成功后，不保证立即可以读到写入的值，也不保证多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（如秒级别）后，数据能够达到一致状态；</p></li><li><p>最终一致性：最终一致性其实是弱一致性的一个特例，系统会保证在一定时间内，能够达到数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上用的比较多的一致性模型。</p></li></ul></blockquote><h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><blockquote><p>它是一个经典的分布式系统理论。CAP 理论告诉我们：一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability ）及分区容错性（P：Partition tolerance）这三个基本要求，最多只能同时满足其中两项。</p><ul><li><p>一致性：所有节点上的数据时刻保持同步</p></li><li><p>可用性：每个请求都能接收一个响应，无论响应成功或失败</p></li><li><p>分区容错：系统应该持续提供服务，即使系统内部（某个节点分区）有消息丢失。比如交换机失败、网址网络被分成几个子网，形成脑裂、服务器发生网络延迟或死机，导致某些Server与集群中的其他机器失去联系。</p></li></ul></blockquote><h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><blockquote><p>在分布式（数据库分片或分库存在的多个实例上）前提下，CAP理论并不适合数据库事务，因为更新一些错误的数据而导致的失败，无论使用什么高可用方案都是徒劳的，因为数据发生了无法修正的错误 。此外，XA事务虽然保证了数据库在分布式系统下的 ACID （原子性、一致性、隔离性、持久性）特性，但同时也带来了一 些性能方面的代价，对于并发和响应时间要求都比较高的电商平台来说，是很难接受的。</p><p>eBay尝试了另外一条完全不同的路，放宽了数据库事务的ACID要求，提出了一套名为BASE的新准则。BASE全称为Basically Available，Soft-state，Eventually Consistent。系统基本可用、软状态、数据最终一致性。</p></blockquote><h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><h2 id="raft"><a href="#raft" class="headerlink" title="raft"></a>raft</h2><h2 id="corosync"><a href="#corosync" class="headerlink" title="corosync"></a>corosync</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">quorum <span class="token punctuation">&#123;</span>        provider: corosync_votequorum　　　　　　<span class="token comment"># 启动了votequorum</span>        expected_votes: <span class="token number">7</span>　　　　　　　　　　　　　 <span class="token comment"># 7表示，7个节点，quorum为4。如果设置了nodelist参数，expected_votes无效</span>        wait_for_all: <span class="token number">1</span>　　　　　　　　　　　　　　 <span class="token comment"># 值为1表示，当集群启动，集群quorum被挂起，直到所有节点在线并加入集群，这个参数是Corosync 2.0新增的。</span>        last_man_standing: <span class="token number">1</span>　　　　　　　　　　   <span class="token comment"># 为1表示，启用LMS特性。默认这个特性是关闭的，即值为0。</span>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<span class="token comment"># 这个参数开启后，当集群的处于表决边缘（如expected_votes=7，而当前online nodes=4），处于表决边缘状态超过last_man_standing_window参数指定的时间，</span>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<span class="token comment"># 则重新计算quorum，直到online nodes=2。如果想让online nodes能够等于1,必须启用auto_tie_breaker选项，生产环境不推荐。</span>        last_man_standing_window: <span class="token number">10000</span>        <span class="token comment"># 单位为毫秒。在一个或多个主机从集群中丢失后，重新计算quorum</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>c-raft集群开发需处理问题：</p><ol><li>需要开发动态更改quorum代码；</li><li>需要开发客户端和服务端代码；（如何连接集群和集群如何处理数据）</li><li>需要开发集群维护代码；（集群监控、查询集群状态、移除添加节点等）</li><li>支持持久化，但当前仅记录变更日志；若要持久化业务，需在开发服务端和客户端时添加相关代码，将业务逻辑写入文件；</li></ol><p>corosync集群开发需处理问题：</p><ol><li>需要开发客户端和服务端代码；（如何连接集群和集群如何处理数据）</li><li>需要开发集群维护代码；（集群监控、查询集群状态、移除添加节点等）</li><li>支持持久化，但当前仅记录变更日志；若要持久化业务，需在开发服务端和客户端时添加相关代码；</li></ol><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ol><li><a href="https://juejin.cn/post/6844903630819033095">https://juejin.cn/post/6844903630819033095</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 集群 </tag>
            
            <tag> corosync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postgresql关键概念理解</title>
      <link href="/2023/02/13/postgresql-guan-jian-gai-nian-li-jie/"/>
      <url>/2023/02/13/postgresql-guan-jian-gai-nian-li-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="postgresql关键概念理解"><a href="#postgresql关键概念理解" class="headerlink" title="postgresql关键概念理解"></a>postgresql关键概念理解</h1><h2 id="wal日志"><a href="#wal日志" class="headerlink" title="wal日志"></a>wal日志</h2><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h2 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h2><h2 id="事务和wal日志的关系"><a href="#事务和wal日志的关系" class="headerlink" title="事务和wal日志的关系"></a>事务和wal日志的关系</h2><h2 id="事务和LSN的关系"><a href="#事务和LSN的关系" class="headerlink" title="事务和LSN的关系"></a>事务和LSN的关系</h2><h2 id="wal日志和LSN的关系"><a href="#wal日志和LSN的关系" class="headerlink" title="wal日志和LSN的关系"></a>wal日志和LSN的关系</h2>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文读懂流复制（postgresql流复制详解）</title>
      <link href="/2023/02/13/postgresql-liu-fu-zhi-xiang-jie/"/>
      <url>/2023/02/13/postgresql-liu-fu-zhi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="一文读懂流复制（postgresql流复制详解）"><a href="#一文读懂流复制（postgresql流复制详解）" class="headerlink" title="一文读懂流复制（postgresql流复制详解）"></a>一文读懂流复制（postgresql流复制详解）</h1><ul><li><p>流复制是postgresql的一种数据复制方式，用于两个postgresql数据库节点之间的数据备份或者数据同步。</p></li><li><p>postgresql使用wal日志保存数据操作记录，再通过操作wal日志对数据操作后将数据写入磁盘。</p></li><li><p>postgresql采用tcp协议来传输wal日志，对wal日志的传输控制及确认采用自定义协议。</p></li><li><p>流复制从流程上来讲，是一个postgresql数据库节点将本地wal日志数据通过网络发送到另外一个数据库节点的过程。</p></li><li><p>postgresql采用多进程模式设计，每个功能都通过创建一个进程来实现。在流复制中，对于发送端来说是walsender进程，对于接收端来说是walreceiver进程。</p></li></ul><p>要理解流复制，需要弄清楚如下几个概念：</p><ul><li>wal日志</li><li>数据发送机制（walsender）</li><li>数据接收机制（walreceiver）</li><li>数据确认机制（自定义协议）</li><li>tcp配置参数（心跳等）</li><li>数据恢复机制（如何将wal日志变成数据）</li><li>进度跟踪机制（状态、进度等）</li></ul><h2 id="wal日志"><a href="#wal日志" class="headerlink" title="wal日志"></a>wal日志</h2><blockquote><p>PostgreSQL在执行数据修改操作时，修改的数据在写入磁盘之前首先要将修改的内容写入wal日志文件，这样就不必时时的将共享缓存中的数据文件刷新到磁盘中，当数据库发生崩溃我们可以从wal日志获取共享缓存中未写入到磁盘的数据。这样做的目的是以顺序写入的wal代替随机的数据写入，以获取更高的执行效率。</p></blockquote><blockquote><p>目前的高性能磁盘，顺序写速度可以达到600MB&#x2F;s， 超过了一般网卡的传输速度。但是磁盘随机写的速度只有大概100KB&#x2F;s，和顺序写的性能相差6000倍。</p></blockquote><h2 id="数据发送机制（walsender）"><a href="#数据发送机制（walsender）" class="headerlink" title="数据发送机制（walsender）"></a>数据发送机制（walsender）</h2><h3 id="数据接收机制（walreceiver）"><a href="#数据接收机制（walreceiver）" class="headerlink" title="数据接收机制（walreceiver）"></a>数据接收机制（walreceiver）</h3><h2 id="数据确认机制（自定义协议）"><a href="#数据确认机制（自定义协议）" class="headerlink" title="数据确认机制（自定义协议）"></a>数据确认机制（自定义协议）</h2><h2 id="tcp配置参数（心跳）"><a href="#tcp配置参数（心跳）" class="headerlink" title="tcp配置参数（心跳）"></a>tcp配置参数（心跳）</h2><h2 id="数据恢复机制"><a href="#数据恢复机制" class="headerlink" title="数据恢复机制"></a>数据恢复机制</h2><h2 id="进度跟踪机制"><a href="#进度跟踪机制" class="headerlink" title="进度跟踪机制"></a>进度跟踪机制</h2><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/163245243">https://zhuanlan.zhihu.com/p/163245243</a></li><li><a href="https://blog.51cto.com/u_15076236/4148373">https://blog.51cto.com/u_15076236/4148373</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> postgresql </tag>
            
            <tag> replication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不得不会的代码注释工具——doxygen</title>
      <link href="/2023/02/13/bu-de-bu-hui-de-dai-ma-zhu-shi-gong-ju-doxygen/"/>
      <url>/2023/02/13/bu-de-bu-hui-de-dai-ma-zhu-shi-gong-ju-doxygen/</url>
      
        <content type="html"><![CDATA[<h1 id="不得不会的代码注释工具——doxygen"><a href="#不得不会的代码注释工具——doxygen" class="headerlink" title="不得不会的代码注释工具——doxygen"></a>不得不会的代码注释工具——doxygen</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官网下载二进制或者直接用yum或apt工具下载。</p><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ul><li><p>进入项目目录生成doxygen配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">doxygen <span class="token parameter variable">-g</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改doxygen配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 程序文档输出目录</span>OUTPUT_DIRECTORY    <span class="token operator">=</span>  doc/<span class="token comment"># 程序文档语言环境</span>OUTPUT_LANGUAGE    <span class="token operator">=</span> Chinese<span class="token comment"># 如果是制作 C 程序文档，该选项必须设为 YES，否则默认生成 C++ 文档格式</span>OPTIMIZE_OUTPUT_FOR_C  <span class="token operator">=</span> YES<span class="token comment"># 对于使用 typedef 定义的结构体、枚举、联合等数据类型，只按照 typedef 定义的类型名进行文档化</span>TYPEDEF_HIDES_STRUCT   <span class="token operator">=</span> YES<span class="token comment"># 在 C++ 程序文档中，该值可以设置为 NO，而在 C 程序文档中，由于 C 语言没有所谓的域/名字空间这样的概念，所以此处设置为 YES</span>HIDE_SCOPE_NAMES        <span class="token operator">=</span> YES<span class="token comment"># 让 doxygen 静悄悄地为你生成文档，只有出现警告或错误时，才在终端输出提示信息</span>QUIET   <span class="token operator">=</span> YES<span class="token comment"># 只对头文件中的文档化信息生成程序文档</span>FILE_PATTERNS          <span class="token operator">=</span> *.h<span class="token comment"># 递归遍历当前目录的子目录，寻找被文档化的程序源文件</span>RECURSIVE              <span class="token operator">=</span> YES<span class="token comment"># 示例程序目录</span>EXAMPLE_PATH           <span class="token operator">=</span> example/<span class="token comment"># 示例程序的头文档 (.h 文件) 与实现文档 (.c 文件) 都作为程序文档化对象</span>EXAMPLE_PATTERNS       <span class="token operator">=</span> *.c <span class="token punctuation">\</span>                               *.h<span class="token comment"># 递归遍历示例程序目录的子目录，寻找被文档化的程序源文件</span>EXAMPLE_RECURSIVE      <span class="token operator">=</span> YES<span class="token comment"># 允许程序文档中显示本文档化的函数相互调用关系</span>REFERENCED_BY_RELATION <span class="token operator">=</span> YESREFERENCES_RELATION    <span class="token operator">=</span> YESREFERENCES_LINK_SOURCE <span class="token operator">=</span> YES<span class="token comment"># 不生成 latex 格式的程序文档</span>GENERATE_LATEX         <span class="token operator">=</span> NO<span class="token comment"># 在程序文档中允许以图例形式显示函数调用关系，前提是你已经安装了 graphviz 软件包</span>HAVE_DOT               <span class="token operator">=</span> YESCALL_GRAPH            <span class="token operator">=</span> YESCALLER_GRAPH        <span class="token operator">=</span> YES<span class="token comment">#让doxygen从配置文件所在的文件夹开始，递归地搜索所有的子目录及源文件</span>RECURSIVE <span class="token operator">=</span> YES  <span class="token comment">#在最后生成的文档中，把所有的源代码包含在其中</span>SOURCE BROWSER <span class="token operator">=</span> YES$这会在HTML文档中，添加一个侧边栏，并以树状结构显示包、类、接口等的关系GENERATE TREEVIEW ＝ ALLEXTRACT_ALL：这个标记告诉 doxygen，即使各个类或函数没有文档，也要提取信息。必须把这个标记设置为 Yes。EXTRACT_PRIVATE：把这个标记设置为 Yes。否则，文档不包含类的私有数据成员。EXTRACT_STATIC：把这个标记设置为 Yes。否则，文档不包含文件的静态成员（函数和变量）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>生成文档</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">doxygen ./Doxyfile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="注释规则"><a href="#注释规则" class="headerlink" title="注释规则"></a>注释规则</h2><h3 id="项目注释"><a href="#项目注释" class="headerlink" title="项目注释"></a>项目注释</h3><blockquote><ul><li>项目注释块用于对项目进行描述，每个项目只出现一次，一般可以放在main.c主函数文件头部。对于其它类型的项目，置于定义项目入口函数的文件中。对于无入口函数的项目，比如静态库项目，置于较关键且不会被外部项目引用的文件中。</li><li>项目注释块以“&#x2F;** @mainpage”开头，以“*&#x2F;”结束。包含项目描述、及功能描述、用法描述、注意事项4个描述章节。</li><li>项目描述章节描述项目名称、作者、代码库目录、项目详细描述4项内容，建议采用HTML的表格语法进行对齐描述。</li><li>功能描述章节列举该项目的主要功能。</li><li>用法描述章节列举该项目的主要使用方法，主要针对动态库、静态库等会被其它项目使用的项目。对于其它类型的项目，该章节可省略。</li><li>注意事项章节描述该项目的注意事项、依赖项目等相关信息</li></ul></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**@mainpage  * @section   项目详细描述** @section   功能描述  * * @section   用法描述 * ***********************************************************************************/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>项目注释也可以使用markdown文件作为主页，通过指定md文件路径来配置。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">USE_MDFILE_AS_MAINPAGE <span class="token operator">=</span> doc/readme.md<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** * @file 文件名 * @brief 简介 * @details 细节 * @mainpage 工程概览 * @author 作者 * @version 版本号 * @date 年-月-日 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="全局常量-x2F-变量-x2F-宏定义-x2F-结构体定义-x2F-类定义的注释"><a href="#全局常量-x2F-变量-x2F-宏定义-x2F-结构体定义-x2F-类定义的注释" class="headerlink" title="全局常量&#x2F;变量&#x2F;宏定义&#x2F;结构体定义&#x2F;类定义的注释"></a>全局常量&#x2F;变量&#x2F;宏定义&#x2F;结构体定义&#x2F;类定义的注释</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/// 缓存大小</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFSIZ</span> <span class="token expression"><span class="token number">1024</span><span class="token operator">*</span><span class="token number">4</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFSIZ</span> <span class="token expression"><span class="token number">1024</span><span class="token operator">*</span><span class="token number">4</span> </span><span class="token comment">///&lt; 缓存大小</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** * @brief 函数简介 * * @param 形参 参数说明 * @param 形参 参数说明 * @return 返回值说明*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li><a href="https://blog.srefan.com/2020/05/doxygen-generate-docs/">https://blog.srefan.com/2020/05/doxygen-generate-docs/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> doxygen </tag>
            
            <tag> document </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leanote使用教程</title>
      <link href="/2023/02/13/leanote-shi-yong-jiao-cheng/"/>
      <url>/2023/02/13/leanote-shi-yong-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="leanote使用教程"><a href="#leanote使用教程" class="headerlink" title="leanote使用教程"></a>leanote使用教程</h1><h2 id="leanote"><a href="#leanote" class="headerlink" title="leanote"></a>leanote</h2><p>leanote的特点就是简约、免费、开源、支持 Markdown 语法，支持程序代码高亮、笔记历史记录、支持笔记分享协作、将笔记发布成博客等功能。</p><h2 id="leanote安装"><a href="#leanote安装" class="headerlink" title="leanote安装"></a>leanote安装</h2><p>leanote使用mongodb存储数据，因而在安装部署之前需要先安装mongodb。</p><p>需要特别注意的是，当前最新版本leanote2.6.1与最新的mongodb6.0.4不兼容，使用mongodb6.0.4时，leanote在连接mongodb时会报错“panic: no reachable server”,因而建议选择mongodb4.0.28。</p><h3 id="mongodb安装"><a href="#mongodb安装" class="headerlink" title="mongodb安装"></a>mongodb安装</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-4.0.28.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压缩后将mongodb的bin目录添加的环境变量。然后输入如下命令检测mongodb是否已正常安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mongod <span class="token parameter variable">--version</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如在windows上输出如下命令，则表明mongodb安装成功：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ mongod <span class="token parameter variable">--version</span>db version v6.0.4Build Info: <span class="token punctuation">&#123;</span>    <span class="token string">"version"</span><span class="token builtin class-name">:</span> <span class="token string">"6.0.4"</span>,    <span class="token string">"gitVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"44ff59461c1353638a71e710f385a566bcd2f547"</span>,    <span class="token string">"modules"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,    <span class="token string">"allocator"</span><span class="token builtin class-name">:</span> <span class="token string">"tcmalloc"</span>,    <span class="token string">"environment"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"distmod"</span><span class="token builtin class-name">:</span> <span class="token string">"windows"</span>,        <span class="token string">"distarch"</span><span class="token builtin class-name">:</span> <span class="token string">"x86_64"</span>,        <span class="token string">"target_arch"</span><span class="token builtin class-name">:</span> <span class="token string">"x86_64"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装成功后需要部署启动mongodb，一般将mongodb部署为一个服务，以windows部署为例。</p><ul><li><p>首先先创建一个mongodb.conf的文件，在文件中写入如下内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">dbpath</span><span class="token operator">=</span>F:<span class="token punctuation">\</span>mongodb<span class="token punctuation">\</span>data            <span class="token comment"># 数据库文件</span><span class="token assign-left variable">logpath</span><span class="token operator">=</span>F:<span class="token punctuation">\</span>mongodb<span class="token punctuation">\</span>logs<span class="token punctuation">\</span>mongodb.log    <span class="token comment"># 日志文件</span><span class="token assign-left variable">logappend</span><span class="token operator">=</span>true                        <span class="token comment"># 日志采用追加模式，配置后mongodb日志会追加到现有的日志文件，不会重新创建一个新文件</span><span class="token assign-left variable">journal</span><span class="token operator">=</span>true                        <span class="token comment"># 启用日志文件，默认启用</span><span class="token assign-left variable">quiet</span><span class="token operator">=</span>true                            <span class="token comment"># 这个选项可以过滤掉一些无用的日志信息，调试模式下设置为 false</span><span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token number">27017</span>                            <span class="token comment"># 端口号 默认为 27017</span><span class="token comment"># 设置绑定ip</span>bind_ip <span class="token operator">=</span> <span class="token number">127.0</span>.0.1<span class="token comment"># 设置端口</span>port <span class="token operator">=</span> <span class="token number">27017</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后使用如下命令注册mongodb为服务(需要以管理员身份运行)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mongod <span class="token parameter variable">--config</span> <span class="token string">"F:\mongodb.conf"</span> <span class="token parameter variable">--install</span><span class="token comment"># 移除服务</span>mongod <span class="token parameter variable">--remove</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>注册成功后启动mongodb</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">net start mongodb<span class="token comment"># 停止服务</span>net stop mongodb <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="安装leanote"><a href="#安装leanote" class="headerlink" title="安装leanote"></a>安装leanote</h3><p>使用如下命令下载leanote最新安装包，或者也可以直接到<a href="https://github.com/leanote/leanote">github</a>上去下载.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://phoenixnap.dl.sourceforge.net/project/leanote-bin/2.6.1/leanote-linux-amd64-v2.6.1.bin.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载完成后进行解压，然后进入到conf目录，修改如下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">site.url</span><span class="token operator">=</span>http://localhost:9000 <span class="token comment"># localhost一定要换成自己的ip，否则客户端无法连接</span><span class="token assign-left variable">db.host</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1 <span class="token comment"># mongodb的ip</span><span class="token assign-left variable">db.port</span><span class="token operator">=</span><span class="token number">27017</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>在运行前需要导入备份数据，使用mongorestore导入，如果找不到mongorestore，需使用如下命令手动下载：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://fastdl.mongodb.org/tools/db/mongodb-database-tools-windows-x86_64-100.6.1.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载解压后将bin目录下文件复制到mongodb的bin目录下。然后使用如下命令将备份数据导入到mongodb：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mongorestore <span class="token parameter variable">-h</span> localhost <span class="token parameter variable">-d</span> leanote <span class="token parameter variable">--dir</span> C:<span class="token punctuation">\</span>user1<span class="token punctuation">\</span>leanote<span class="token punctuation">\</span>mongodb_backup<span class="token punctuation">\</span>leanote_install_data<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导入成功数据后将包含两个默认用户：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">user1 username: admin, password: abc123 <span class="token punctuation">(</span>管理员, 只有该用户可以管理后台<span class="token punctuation">)</span>  user2 username: demo@leanote.com, password: demo@leanote.com <span class="token punctuation">(</span>仅供体验使用<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后进入到bin目录下面，双击运行run.dat。</p><p>若运行失败，切换到管理员身份运行。</p><p>若运行失败查不到原因，可在命令行中运行run.bat或者在run.bat末尾加上pause。</p><p>运行成功后，cmd窗口会显示监听的端口，使用ip:port的方式访问leanote。如<a href="http://localhost:9000/">http://localhost:9000</a>.</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> blog </tag>
            
            <tag> leanote </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper主备集群demo</title>
      <link href="/2023/02/10/zookeeper-zhu-bei-ji-qun-demo/"/>
      <url>/2023/02/10/zookeeper-zhu-bei-ji-qun-demo/</url>
      
        <content type="html"><![CDATA[<h1 id="zookeeper主备集群demo"><a href="#zookeeper主备集群demo" class="headerlink" title="zookeeper主备集群demo"></a>zookeeper主备集群demo</h1><p>使用zookeeper搭建主备集群，要求实现如下功能：</p><ul><li>有且只有一个节点作为master，履行master的职责，在例子中是注册调度器；</li><li>其他实例作为slave，不提供调度功能，但是在master节点挂掉之后，可以重新进行选主调度。</li></ul><h2 id="kazoo"><a href="#kazoo" class="headerlink" title="kazoo"></a>kazoo</h2><p>搭建好zookeeper后，需要使用zookeeper 客户端来连接zookeeper，并在zookeeper中写入相关信息。本次测试demo使用python编写，因而使用zookeeper的python客户端来kazoo来与zookeeper进行通信。</p><p>kazoo的安装流程如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> kazoo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以从github上下载源码进行安装，</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/python-zk/kazoo.git<span class="token builtin class-name">cd</span> kazoopython3 setup.py <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="zookeeper部署"><a href="#zookeeper部署" class="headerlink" title="zookeeper部署"></a>zookeeper部署</h2><p>使用两台机器部署zookeeper，部署过程如下：</p><ul><li><p>安装openjdk并设置JAVA_HOME</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> openjdk-8-jdk<span class="token builtin class-name">export</span> <span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/usr/lib/jvm/java-8-openjdk-amd64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>下载zookeeper</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/stable/apache-zookeeper-3.6.3-bin.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color="red">注意：下载时需下载带bin的包，否则会在启动时报找不到主类的错。</font></p></li><li><p>安装zookeeper</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /opt<span class="token function">tar</span> <span class="token parameter variable">-xvf</span> apache-zookeeper-3.6.3-bin.tar.gz<span class="token builtin class-name">export</span> <span class="token assign-left variable">ZOOKEEPER_HOME</span><span class="token operator">=</span>/opt/apache-zookeeper-3.6.3-bin<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$ZOOKEEPER_HOME</span>/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置zookeeper</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /opt<span class="token function">mkdir</span> data<span class="token function">mkdir</span> logs<span class="token builtin class-name">cd</span> /opt/apache-zookeeper-3.6.3-bin/conf<span class="token function">vim</span> zoo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>zoo.cfg的文件内容如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">tickTime</span><span class="token operator">=</span><span class="token number">2000</span><span class="token assign-left variable">initLimit</span><span class="token operator">=</span><span class="token number">10</span><span class="token assign-left variable">syncLimit</span><span class="token operator">=</span><span class="token number">5</span><span class="token assign-left variable">dataDir</span><span class="token operator">=</span>/opt/data<span class="token assign-left variable">dataLogDir</span><span class="token operator">=</span>/opt/logs<span class="token assign-left variable">clientPort</span><span class="token operator">=</span><span class="token number">2181</span><span class="token assign-left variable">server.1</span><span class="token operator">=</span>ip1:2888:3888<span class="token assign-left variable">server.2</span><span class="token operator">=</span>ip2:2888:3888<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给每台zookeeper分配id：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 对节点1执行</span><span class="token builtin class-name">echo</span> <span class="token string">"1"</span> <span class="token operator">>></span> /opt/data/myid<span class="token comment"># 对节点2执行</span><span class="token builtin class-name">echo</span> <span class="token string">"2"</span> <span class="token operator">>></span> /opt/data/myid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /opt/apache-zookeeper-3.6.3-bin/bin./zkServer.sh start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /opt/apache-zookeeper-3.6.3-bin/bin./zkServer.sh status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>连接服务端</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /opt/apache-zookeeper-3.6.3-bin/bin./zkCli.sh <span class="token parameter variable">-server</span> ip1:2181<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="demo执行"><a href="#demo执行" class="headerlink" title="demo执行"></a>demo执行</h2><p>demo代码run.py如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token keyword">import</span> socket<span class="token keyword">import</span> traceback<span class="token keyword">import</span> time<span class="token keyword">from</span> kazoo<span class="token punctuation">.</span>client <span class="token keyword">import</span> KazooClient<span class="token keyword">from</span> kazoo<span class="token punctuation">.</span>client <span class="token keyword">import</span> KazooState<span class="token comment"># 调度器注册和关闭</span><span class="token comment"># 模拟主节点的职责</span><span class="token keyword">class</span> <span class="token class-name">MyScheduler</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 注册调度器</span>    <span class="token keyword">def</span> <span class="token function">init_scheduler</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'########## 开启调度器成功 ############'</span><span class="token punctuation">)</span>    <span class="token comment"># 关闭调度器</span>    <span class="token keyword">def</span> <span class="token function">stop_scheduler</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'########## 关闭调度器成功 ############'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">HAMaster</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token string">'/dmonitor/master'</span>        self<span class="token punctuation">.</span>scheduler <span class="token operator">=</span> MyScheduler<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#self.zk = KazooClient('localhost:2181,10.93.18.34:2181,10.93.18.35:2181', timeout=10)</span>        self<span class="token punctuation">.</span>zk <span class="token operator">=</span> KazooClient<span class="token punctuation">(</span><span class="token string">'localhost:2181'</span><span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>zk<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>zk<span class="token punctuation">.</span>add_listener<span class="token punctuation">(</span>self<span class="token punctuation">.</span>my_listener<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>is_leader <span class="token operator">=</span> <span class="token boolean">False</span>    <span class="token keyword">def</span> <span class="token function">create_instance</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        instance <span class="token operator">=</span> self<span class="token punctuation">.</span>path <span class="token operator">+</span> <span class="token string">'/'</span> <span class="token operator">+</span> socket<span class="token punctuation">.</span>gethostbyname<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>gethostname<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'-'</span>        self<span class="token punctuation">.</span>zk<span class="token punctuation">.</span>create<span class="token punctuation">(</span>path<span class="token operator">=</span>instance<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">b"test"</span><span class="token punctuation">,</span> ephemeral<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> sequence<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> makepath<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment"># 选主逻辑: master节点下, 所有ephemeral+sequence类型的节点中, 编号最大的获得领导权.</span>    <span class="token keyword">def</span> <span class="token function">choose_master</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"########## 选主开始 ############"</span><span class="token punctuation">)</span>        instance_list <span class="token operator">=</span> self<span class="token punctuation">.</span>zk<span class="token punctuation">.</span>get_children<span class="token punctuation">(</span>path<span class="token operator">=</span>self<span class="token punctuation">.</span>path<span class="token punctuation">,</span> watch<span class="token operator">=</span>self<span class="token punctuation">.</span>my_watcher<span class="token punctuation">)</span>        instance <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>instance_list<span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token comment"># 本实例获得领导权</span>        <span class="token keyword">if</span> instance <span class="token operator">==</span> socket<span class="token punctuation">.</span>gethostbyname<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>gethostname<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>is_leader<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>scheduler<span class="token punctuation">.</span>init_scheduler<span class="token punctuation">(</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>is_leader <span class="token operator">=</span> <span class="token boolean">True</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"######### 我被选为master, 我以前不是master, 注册调度 ##########"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"######### 我被选为master, 我以前是master, 不再注册调度 ##########"</span><span class="token punctuation">)</span>        <span class="token comment"># 本实例没有获得领导权</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_leader<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>scheduler<span class="token punctuation">.</span>stop_scheduler<span class="token punctuation">(</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>is_leader <span class="token operator">=</span> <span class="token boolean">False</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"######### 我被选为slave, 我以前不是slave, 关闭调度 ##########"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"######### 我被选为slave, 我以前是slave, 不再关闭调度 ##########"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"########## 选主完成 ############"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">my_listener</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> state <span class="token operator">==</span> KazooState<span class="token punctuation">.</span>LOST<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"########## 会话超时:KazooState.LOST ############"</span><span class="token punctuation">)</span>            <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>                <span class="token keyword">try</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>create_instance<span class="token punctuation">(</span><span class="token punctuation">)</span>                    self<span class="token punctuation">.</span>zk<span class="token punctuation">.</span>get_children<span class="token punctuation">(</span>path<span class="token operator">=</span>self<span class="token punctuation">.</span>path<span class="token punctuation">,</span> watch<span class="token operator">=</span>self<span class="token punctuation">.</span>my_watcher<span class="token punctuation">)</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"########## 会话超时:重建会话完成! ############"</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span>                <span class="token keyword">except</span> <span class="token punctuation">(</span>Exception<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">:</span>                    traceback<span class="token punctuation">.</span>print_exc<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> state <span class="token operator">==</span> KazooState<span class="token punctuation">.</span>SUSPENDED<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"########## 会话超时:KazooState.SUSPENDED ############"</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> state <span class="token operator">==</span> KazooState<span class="token punctuation">.</span>CONNECTED<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"########## 会话超时:KazooState.CONNECTED ############"</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"########## 会话超时:非法状态 ############"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">my_watcher</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> event<span class="token punctuation">.</span>state <span class="token operator">==</span> <span class="token string">"CONNECTED"</span> <span class="token keyword">and</span> event<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> <span class="token string">"CREATED"</span> <span class="token keyword">or</span> event<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> <span class="token string">"DELETED"</span> <span class="token keyword">or</span> event<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> <span class="token string">"CHANGED"</span> <span class="token keyword">or</span> event<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> <span class="token string">"CHILD"</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"########## 监听到子节点变化事件 ############"</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>choose_master<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"########## 监听到未识别的事件 ############"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    ha <span class="token operator">=</span> HAMaster<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 向zk注册自己</span>    ha<span class="token punctuation">.</span>create_instance<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 进行选主</span>    ha<span class="token punctuation">.</span>choose_master<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    run<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>demo模拟一个调度器的服务，且同一时刻仅有一个master节点在提供调度服务。</p><ul><li>当有新节点加入时，自动成为备节点，仅作为备份，不提供服务</li><li>当master节点挂掉时，选择一个备节点，提升为主节点</li></ul><p>在部署好zookeeper后，分别在各节点上执行如下命令模拟主备集群启动：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 run.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注册服务的大致流程如下：</p><ol><li>首先服务启动时会先向zookeeper注册，注册会在&#x2F;dmonitor&#x2F;master&#x2F;下创建节点，命名方式为本机ip和zookeeper生成的sequence，并用“-”连接，如127.0.1.1-0000000001；</li><li>在&#x2F;dmonitor&#x2F;master&#x2F;下创建的节点为临时节点，当与zookeeper相连的客户端断开时，其对应的节点也会被删除，其他调度服务通过watch感知节点变化；</li><li>每个加入的服务注册好节点后就会进行选master选择，然后根据名称中sequence大的选为master；</li><li>同时，每个调度服务都会对&#x2F;dmonitor&#x2F;master&#x2F;下面的节点设置watch，当其下的节点发生变化时，会重新进入选master的阶段；</li></ol><h2 id="模拟主备集群"><a href="#模拟主备集群" class="headerlink" title="模拟主备集群"></a>模拟主备集群</h2><p>未启动调度服务时zookeeper的znode信息如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>zk: localhost:2181<span class="token punctuation">(</span>CONNECTED<span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token function">ls</span> /<span class="token punctuation">[</span>my, zookeeper<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="启动主节点调度服务"><a href="#启动主节点调度服务" class="headerlink" title="启动主节点调度服务"></a>启动主节点调度服务</h3><p>首先启动节点1的调度服务，其执行结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ha@machine1:~/code/kazoo_test$ python3 run.py<span class="token comment">########## 选主开始 ############</span><span class="token comment">########## 开启调度器成功 ############</span><span class="token comment">######### 我被选为master, 我以前不是master, 注册调度 ##########</span><span class="token comment">########## 选主完成 ############</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当只有一个节点有调度服务时，节点1的调度服务被选为主节点。此时再来查看zookeeper的znode信息，可以看到znode多了存储master信息的节点：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>zk: localhost:2181<span class="token punctuation">(</span>CONNECTED<span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token function">ls</span> /<span class="token punctuation">[</span>dmonitor, my, zookeeper<span class="token punctuation">]</span><span class="token punctuation">[</span>zk: localhost:2181<span class="token punctuation">(</span>CONNECTED<span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token function">ls</span> /dmonitor/master<span class="token punctuation">[</span><span class="token number">192.168</span>.145.131-0000000000<span class="token punctuation">]</span><span class="token punctuation">[</span>zk: localhost:2181<span class="token punctuation">(</span>CONNECTED<span class="token punctuation">)</span> <span class="token number">2</span><span class="token punctuation">]</span> get /dmonitor/master/192.168.145.131-0000000000<span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到&#x2F;dmonitor&#x2F;master节点下面存储了成为主服务的ip信息，此时master为192.168.145.131。</p><h3 id="启动备节点调度服务"><a href="#启动备节点调度服务" class="headerlink" title="启动备节点调度服务"></a>启动备节点调度服务</h3><p>接着我们在节点2上启动调度服务，同样执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 run.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其执行结果如下，因为已经存在master了，所以成为slaver服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ha@machine2:~/code/kazoo_test$ python3 run.py<span class="token comment">########## 选主开始 ############</span><span class="token comment">######### 我被选为slave, 我以前是slave, 不再关闭调度 ##########</span><span class="token comment">########## 选主完成 ############</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同时因为master设置对&#x2F;dmonitor&#x2F;maste的watch，因而当新节点插入时，也会进入选master的阶段。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ha@machine1:~/code/kazoo_test$ python3 run.py<span class="token comment">########## 选主开始 ############</span><span class="token comment">########## 开启调度器成功 ############</span><span class="token comment">######### 我被选为master, 我以前不是master, 注册调度 ##########</span><span class="token comment">########## 选主完成 ############</span><span class="token comment">########## 监听到子节点变化事件 ############</span><span class="token comment">########## 选主开始 ############</span><span class="token comment">######### 我被选为master, 我以前是master, 不再注册调度 ##########</span><span class="token comment">########## 选主完成 ############</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但此时master不变，仍然为192.168.145.131。</p><p>此时查看zookeeper的znode，结果如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>zk: localhost:2181<span class="token punctuation">(</span>CONNECTED<span class="token punctuation">)</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token function">ls</span> /dmonitor/master<span class="token punctuation">[</span><span class="token number">192.168</span>.145.130-0000000001, <span class="token number">192.168</span>.145.131-0000000000<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到&#x2F;dmonitor&#x2F;master当前有两个ip信息。</p><h3 id="主备切换"><a href="#主备切换" class="headerlink" title="主备切换"></a>主备切换</h3><h3 id="模拟master服务器挂掉"><a href="#模拟master服务器挂掉" class="headerlink" title="模拟master服务器挂掉"></a>模拟master服务器挂掉</h3><p>主备调度服务起来后，我们模拟主备切换的过程。当前的master为192.168.145.131，停掉该机器上的调度服务，查看192.168.145.130是否能升master。</p><p>可以看到，成功升级成为master，日志如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ha@machine2:~/code/kazoo_test$ python3 run.py<span class="token comment">########## 选主开始 ############</span><span class="token comment">######### 我被选为slave, 我以前是slave, 不再关闭调度 ##########</span><span class="token comment">########## 选主完成 ############</span><span class="token comment">########## 监听到子节点变化事件 ############</span><span class="token comment">########## 选主开始 ############</span><span class="token comment">########## 开启调度器成功 ############</span><span class="token comment">######### 我被选为master, 我以前不是master, 注册调度 ##########</span><span class="token comment">########## 选主完成 ############</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在查看zookeeper的znode信息，</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>zk: localhost:2181<span class="token punctuation">(</span>CONNECTED<span class="token punctuation">)</span> <span class="token number">10</span><span class="token punctuation">]</span> <span class="token function">ls</span> /dmonitor/master<span class="token punctuation">[</span><span class="token number">192.168</span>.145.130-0000000001<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到192.168.145.131的信息已经从zookeeper中删除了，此时192.168.145.130机器的调度服务升级为master。</p><h3 id="重启master服务器"><a href="#重启master服务器" class="headerlink" title="重启master服务器"></a>重启master服务器</h3><p>master从192.168.145.131切换为192.168.145.130后，我们再重启192.168.145.131的调度服务。</p><p>在192.168.145.130机器可以看到192.168.145.130从master重新切换为slaver。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ha@machine2:~/code/kazoo_test$ python3 run.py<span class="token comment">########## 选主开始 ############</span><span class="token comment">######### 我被选为slave, 我以前是slave, 不再关闭调度 ##########</span><span class="token comment">########## 选主完成 ############</span><span class="token comment">########## 监听到子节点变化事件 ############</span><span class="token comment">########## 选主开始 ############</span><span class="token comment">########## 开启调度器成功 ############</span><span class="token comment">######### 我被选为master, 我以前不是master, 注册调度 ##########</span><span class="token comment">########## 选主完成 ############</span><span class="token comment">########## 监听到子节点变化事件 ############</span><span class="token comment">########## 选主开始 ############</span><span class="token comment">########## 关闭调度器成功 ############</span><span class="token comment">######### 我被选为slave, 我以前不是slave, 关闭调度 ##########</span><span class="token comment">########## 选主完成 ############</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而新启动的192.168.145.131则直接成为master。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ha@machine1:~/code/kazoo_test$ python3 run.py<span class="token comment">########## 选主开始 ############</span><span class="token comment">########## 开启调度器成功 ############</span><span class="token comment">######### 我被选为master, 我以前不是master, 注册调度 ##########</span><span class="token comment">########## 选主完成 ###########</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看zookeeper的znode信息，可以看到ip信息已更新。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>zk: localhost:2181<span class="token punctuation">(</span>CONNECTED<span class="token punctuation">)</span> <span class="token number">11</span><span class="token punctuation">]</span> <span class="token function">ls</span> /dmonitor/master<span class="token punctuation">[</span><span class="token number">192.168</span>.145.130-0000000001, <span class="token number">192.168</span>.145.131-0000000002<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h2><p>【开发云】年年都是折扣价，不用四处薅羊毛 <a href="https://dev.csdn.net/activity?utm_source=sale_source&sale_source=Igt9xAFU3H">https://dev.csdn.net/activity?utm_source=sale_source&amp;sale_source=Igt9xAFU3H</a></p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ol><li><a href="https://cloud.tencent.com/developer/article/1050471">https://cloud.tencent.com/developer/article/1050471</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>use-code-server</title>
      <link href="/2022/08/07/use-code-server/"/>
      <url>/2022/08/07/use-code-server/</url>
      
        <content type="html"><![CDATA[<h1 id="code-server安装"><a href="#code-server安装" class="headerlink" title="code-server安装"></a>code-server安装</h1><p>code-server是C&#x2F;S架构，一般将服务端部署在linux机器上，然后我们就可以在windows端通过浏览器来访问linux机器上的代码。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz<span class="token function">tar</span> <span class="token parameter variable">-xvf</span> code-server-4.5.1-linux-amd64.tar.gz<span class="token builtin class-name">cd</span> code-server-4.5.1-linux-amd64./code-server <span class="token parameter variable">--host</span> <span class="token function">ip</span> <span class="token parameter variable">--port</span> port<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端可以使用chrome的app模式来启动，具体执行脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1.bat</span>start <span class="token string">""</span> <span class="token string">"C:\Program Files\Google\Chrome\Application<span class="token entity" title="\c">\c</span>hrome.exe"</span> <span class="token parameter variable">--app</span><span class="token operator">=</span>http://host:port/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>服务端启动后，双击1.bat文件即可以访问linux服务器代码。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> node </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcpdump抓包</title>
      <link href="/2022/08/05/tcpdump-zhua-bao/"/>
      <url>/2022/08/05/tcpdump-zhua-bao/</url>
      
        <content type="html"><![CDATA[<h1 id="抓包进阶"><a href="#抓包进阶" class="headerlink" title="抓包进阶"></a>抓包进阶</h1><h2 id="抓包命令"><a href="#抓包命令" class="headerlink" title="抓包命令"></a>抓包命令</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcpdump <span class="token parameter variable">-i</span> eth1 <span class="token parameter variable">-vvv</span> <span class="token parameter variable">-w</span> test.pcap<span class="token comment"># -i 指定网口</span><span class="token comment"># -vvv 在shell中显示抓到的包</span><span class="token comment"># -w 将抓到的包写入文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>指定主机名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcpdump <span class="token parameter variable">-i</span> eth1 <span class="token function">host</span> www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>指定ip</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcpdump <span class="token parameter variable">-i</span> eth1 <span class="token function">host</span> <span class="token number">192.168</span>.1.12<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>指定端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcpdump <span class="token parameter variable">-i</span> eth1 port <span class="token number">80</span><span class="token comment"># 指定源端口</span>tcpdump <span class="token parameter variable">-i</span> eth1 src port <span class="token number">80</span><span class="token comment"># 指定目的端口</span>tcpdump <span class="token parameter variable">-i</span> eth1 dst port <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>指定协议</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 对于传输层之上的协议需加port</span>tcpdump <span class="token parameter variable">-i</span> eth1 port http<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>指定icmp</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ping打包</span><span class="token function">ping</span> <span class="token parameter variable">-s</span> <span class="token number">4800</span> <span class="token function">ip</span><span class="token comment"># 抓取ping包</span><span class="token comment"># 传输层及传输层之下的协议直接跟协议名</span>tcpdump <span class="token parameter variable">-i</span> eth1 icmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>当需要长时间抓包时，为避免单个抓包文件过大导致打开查询缓慢，可设置当个抓包文件大小</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 指定单个抓包文件大小为100M，超过100M会保存在新文件中</span>tcpdump <span class="token parameter variable">-i</span> eth1 <span class="token parameter variable">-C</span> 100M <span class="token parameter variable">-w</span> test.pcap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="拆分包"><a href="#拆分包" class="headerlink" title="拆分包"></a>拆分包</h2><p>当单个文件报文个数过多时，打开和查询报文缓慢。可以使用wireshark相关工具对其进行拆分。</p><p>进入wireshark的安装目录，可以看到有一个editcap的程序。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -c 指定多少个包拆分为一个文件， src待拆分的包文件路径及文件名，dst是拆分后的文件路径及文件名</span>editcap.exe <span class="token parameter variable">-c</span> <span class="token number">200000</span> src dst<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="合并包"><a href="#合并包" class="headerlink" title="合并包"></a>合并包</h2><p>Mergecap 从名字上 可以看出该命令的功能是合并多个报文为一个报文。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">C:<span class="token punctuation">\</span>Program Files<span class="token punctuation">\</span>Wireshark<span class="token operator">></span>mergecap <span class="token parameter variable">-h</span>Mergecap <span class="token punctuation">(</span>Wireshark<span class="token punctuation">)</span> <span class="token number">3.4</span>.2 <span class="token punctuation">(</span>v3.4.2-0-ga889cf1b1bf9<span class="token punctuation">)</span>Merge two or <span class="token function">more</span> capture files into one.See https://www.wireshark.org <span class="token keyword">for</span> <span class="token function">more</span> information.Usage: mergecap <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token parameter variable">-w</span> <span class="token operator">&lt;</span>outfile<span class="token operator">>|</span>- <span class="token operator">&lt;</span>infile<span class="token operator">></span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>infile<span class="token operator">></span> <span class="token punctuation">..</span>.<span class="token punctuation">]</span>Output:  <span class="token parameter variable">-a</span>                concatenate rather than merge files.                    default is to merge based on frame timestamps.  <span class="token parameter variable">-s</span> <span class="token operator">&lt;</span>snaplen<span class="token operator">></span>      truncate packets to <span class="token operator">&lt;</span>snaplen<span class="token operator">></span> bytes of data.  <span class="token parameter variable">-w</span> <span class="token operator">&lt;</span>outfile<span class="token operator">>|</span>-    <span class="token builtin class-name">set</span> the output filename to <span class="token operator">&lt;</span>outfile<span class="token operator">></span> or <span class="token string">'-'</span> <span class="token keyword">for</span> stdout.  <span class="token parameter variable">-F</span> <span class="token operator">&lt;</span>capture type<span class="token operator">></span> <span class="token builtin class-name">set</span> the output <span class="token function">file</span> <span class="token builtin class-name">type</span><span class="token punctuation">;</span> default is pcapng.                    an empty <span class="token string">"-F"</span> option will list the <span class="token function">file</span> types.  <span class="token parameter variable">-I</span> <span class="token operator">&lt;</span>IDB merge mode<span class="token operator">></span> <span class="token builtin class-name">set</span> the merge mode <span class="token keyword">for</span> Interface Description Blocks<span class="token punctuation">;</span> default is <span class="token string">'all'</span><span class="token builtin class-name">.</span>                    an empty <span class="token string">"-I"</span> option will list the merge modes.Miscellaneous:  <span class="token parameter variable">-h</span>                display this <span class="token builtin class-name">help</span> and exit.  <span class="token parameter variable">-v</span>                verbose output.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mergecap <span class="token parameter variable">-v</span> <span class="token parameter variable">-a</span> <span class="token parameter variable">-F</span> pcap <span class="token parameter variable">-w</span> test.pcapmergecap <span class="token parameter variable">-v</span> <span class="token parameter variable">-a</span> userip-1.pcap userip-2.pcap <span class="token parameter variable">-F</span> pcap <span class="token parameter variable">-w</span> merge_out.pcap    -v参数表示打印每一片报文的编号，报文较多的话会打屏。    -a参数表示的是按照文件中顺序将报文进行合并，默认情况是按照时间戳的顺序进行合并。由于每一片报文头部都是由有时间戳信息的，不明白的可以查看这里。    -F表示文件的存储格式，例如pcap,pcapng等等。在-F后面参数为空的情况下，会列出该命令支持的所有文件格式，对照选择即可。    -w即文件输出的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="合并一定比例的包"><a href="#合并一定比例的包" class="headerlink" title="合并一定比例的包"></a>合并一定比例的包</h2><p>使用python脚本构造固定比例的包，如1:1024等。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> osbase_file <span class="token operator">=</span> <span class="token string">"5gc.pcap"</span>arp_file <span class="token operator">=</span> <span class="token string">"arp_request.pcap"</span>ratio <span class="token operator">=</span> <span class="token number">0</span>dst_file <span class="token operator">=</span> <span class="token string">""</span>pwd <span class="token operator">=</span> os<span class="token punctuation">.</span>curdir<span class="token keyword">for</span> num <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    ratio <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span>    copy_file <span class="token operator">=</span> <span class="token string">"5gc_copy_"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".pcap"</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">'copy %s %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>base_file<span class="token punctuation">,</span> copy_file<span class="token punctuation">)</span><span class="token punctuation">)</span>    dst_file <span class="token operator">=</span> <span class="token string">"5gc_"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>ratio<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".pcap"</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"mergecap.exe -v -a %s %s -F pcap -w %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>base_file<span class="token punctuation">,</span> copy_file<span class="token punctuation">,</span> dst_file<span class="token punctuation">)</span><span class="token punctuation">)</span>    base_file <span class="token operator">=</span> dst_file    dst_arp_file <span class="token operator">=</span> <span class="token string">"5gc_arp_1_"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>ratio<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".pcap"</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"mergecap.exe -v -a %s %s -F pcap -w %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>base_file<span class="token punctuation">,</span> arp_file<span class="token punctuation">,</span> dst_arp_file<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查询包"><a href="#查询包" class="headerlink" title="查询包"></a>查询包</h2><p>一般获取抓包文件后，需要使用wireshark对包进行查询和分析。常见的查询命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcp <span class="token comment"># 过滤tcp报文</span>ip.addr <span class="token operator">==</span> <span class="token number">127.0</span>.0.1 <span class="token comment"># 根据ip地址过滤</span>tcp.flags.reset <span class="token operator">==</span> <span class="token number">1</span> <span class="token comment"># 过滤reset报文</span>tcp.port <span class="token operator">==</span> <span class="token number">8080</span> <span class="token comment"># 根据端口过滤</span>tcp.len <span class="token operator">></span> <span class="token number">0</span> <span class="token comment"># 根据tcp数据长度过滤</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>1.<a href="https://www.freesion.com/article/9386244731/">https://www.freesion.com/article/9386244731/</a></p>]]></content>
      
      
      <categories>
          
          <category> tcp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tcp </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker与宿主机共享内存通信</title>
      <link href="/2022/08/03/docker-yu-su-zhu-ji-gong-xiang-nei-cun-tong-xin/"/>
      <url>/2022/08/03/docker-yu-su-zhu-ji-gong-xiang-nei-cun-tong-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="docker与宿主机共享内存通信"><a href="#docker与宿主机共享内存通信" class="headerlink" title="docker与宿主机共享内存通信"></a>docker与宿主机共享内存通信</h1><p>docker中的进程要与宿主机使用共享内存通信，需要在启动容器的时候指定<font color="red">“–ipc&#x3D;host”</font>选项。然后再编写相应的共享内存的程序，一个跑在宿主机上，另一个跑在docker上面。</p><h2 id="宿主机程序准备"><a href="#宿主机程序准备" class="headerlink" title="宿主机程序准备"></a>宿主机程序准备</h2><ul><li>shm_data.h</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_SHMDATA_H_HEADER</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_SHMDATA_H_HEADER</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TEXT_SZ</span> <span class="token expression"><span class="token number">2048</span></span></span> <span class="token keyword">struct</span> <span class="token class-name">shared_use_st</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> written<span class="token punctuation">;</span> <span class="token comment">// 作为一个标志，非0：表示可读，0：表示可写</span>    <span class="token keyword">char</span> text<span class="token punctuation">[</span>TEXT_SZ<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录写入 和 读取 的文本</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>shm_slave.c</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"shmdata.h"</span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>shm <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">shared_use_st</span> <span class="token operator">*</span>shared <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUFSIZ <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用于保存输入的文本</span>    <span class="token keyword">int</span> shmid<span class="token punctuation">;</span>     <span class="token comment">// 创建共享内存</span>    shmid <span class="token operator">=</span> <span class="token function">shmget</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">key_t</span><span class="token punctuation">)</span><span class="token number">1234</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">shared_use_st</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0666</span><span class="token operator">|</span>IPC_CREAT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shmid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"shmget failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 将共享内存连接到当前的进程地址空间</span>    shm <span class="token operator">=</span> <span class="token function">shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shm <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"shmat failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Memory attched at %X\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>shm<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 设置共享内存</span>    shared <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">shared_use_st</span> <span class="token operator">*</span><span class="token punctuation">)</span>shm<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 向共享内存中写数据</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">// 数据还没有被读取，则等待数据被读取，不能向共享内存中写入文本</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>shared<span class="token operator">-></span>written <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Waiting...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token comment">// 向共享内存中写入数据</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Enter some text: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fgets</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> BUFSIZ<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">strncpy</span><span class="token punctuation">(</span>shared<span class="token operator">-></span>text<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> TEXT_SZ<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 写完数据，设置written使共享内存段可读</span>        shared<span class="token operator">-></span>written <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment">// 输入了end，退出循环（程序）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strncmp</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">"end"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 把共享内存从当前进程中分离</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shmdt</span><span class="token punctuation">(</span>shm<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"shmdt failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>makefile</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span>gcc -o shm_slave shm_slave.c<span class="token target symbol">clean</span><span class="token punctuation">:</span>rm -rf shm_slave<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="docker镜像准备"><a href="#docker镜像准备" class="headerlink" title="docker镜像准备"></a>docker镜像准备</h2><ul><li>shm_data.h</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_SHMDATA_H_HEADER</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_SHMDATA_H_HEADER</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TEXT_SZ</span> <span class="token expression"><span class="token number">2048</span></span></span> <span class="token keyword">struct</span> <span class="token class-name">shared_use_st</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> written<span class="token punctuation">;</span> <span class="token comment">// 作为一个标志，非0：表示可读，0：表示可写</span>    <span class="token keyword">char</span> text<span class="token punctuation">[</span>TEXT_SZ<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录写入 和 读取 的文本</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>shm_master.c</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stddef.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"shmdata.h"</span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>shm <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">shared_use_st</span> <span class="token operator">*</span>shared<span class="token punctuation">;</span> <span class="token comment">// 指向shm</span>    <span class="token keyword">int</span> shmid<span class="token punctuation">;</span> <span class="token comment">// 共享内存标识符</span>    <span class="token comment">// 将内容写入到文件，可以通过查看文件确定共享内存是否成功</span>    FILE<span class="token operator">*</span> file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"t.txt"</span><span class="token punctuation">,</span><span class="token string">"w+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 创建共享内存</span>    shmid <span class="token operator">=</span> <span class="token function">shmget</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">key_t</span><span class="token punctuation">)</span><span class="token number">1234</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">shared_use_st</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0666</span><span class="token operator">|</span>IPC_CREAT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shmid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"shmat failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 将共享内存连接到当前进程的地址空间</span>    shm <span class="token operator">=</span> <span class="token function">shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shm <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"shmat failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nMemory attached at %X\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>shm<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 设置共享内存</span>    shared <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">shared_use_st</span><span class="token operator">*</span><span class="token punctuation">)</span>shm<span class="token punctuation">;</span> <span class="token comment">// 注意：shm有点类似通过 malloc() 获取到的内存，所以这里需要做个 类型强制转换</span>    shared<span class="token operator">-></span>written <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 读取共享内存中的数据</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">// 没有进程向内存写数据，有数据可读取</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>shared<span class="token operator">-></span>written <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"You wrote: %s"</span><span class="token punctuation">,</span> shared<span class="token operator">-></span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">fputs</span><span class="token punctuation">(</span>shared<span class="token operator">-></span>text<span class="token punctuation">,</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">fflush</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 读取完数据，设置written使共享内存段可写</span>            shared<span class="token operator">-></span>written <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment">// 输入了 end，退出循环（程序）</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strncmp</span><span class="token punctuation">(</span>shared<span class="token operator">-></span>text<span class="token punctuation">,</span> <span class="token string">"end"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token comment">// 有其他进程在写数据，不能读取数据</span>        <span class="token punctuation">&#123;</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 把共享内存从当前进程中分离</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shmdt</span><span class="token punctuation">(</span>shm<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"shmdt failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">flcose</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 删除共享内存</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shmctl</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> IPC_RMID<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"shmctl(IPC_RMID) failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fclose</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token function">flcose</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>makefile</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span>gcc -o shm_master shm_master.c<span class="token target symbol">clean</span><span class="token punctuation">:</span>rm -rf shm_master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Dockerfile</li></ul><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> gcc:latest</span><span class="token instruction"><span class="token keyword">RUN</span>  mkdir /usr/src/shm_test</span><span class="token instruction"><span class="token keyword">COPY</span> shm_master.c shm_data.h makefile /usr/src/shm_test/</span><span class="token instruction"><span class="token keyword">WORKDIR</span> /usr/src/shm_test</span><span class="token instruction"><span class="token keyword">RUN</span>  make</span><span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"./shm_master"</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>运行时需要先下载docker，获取支持c语言编译运行的基础镜像，比如ubuntu、gcc等。这里使用gcc作为基础镜像。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">docker</span><span class="token function">sudo</span> <span class="token function">docker</span> pull gcc<span class="token comment"># 查看一下gcc的镜像是否拉取下来了</span><span class="token function">docker</span> images<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>基础镜像有了后就可以基于基础镜像构建docker容器，基于上面所写的dockerfile，构建镜像：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> build <span class="token parameter variable">-t</span> shm_master:v1 <span class="token builtin class-name">.</span><span class="token comment"># 查看镜像是否创建成功</span><span class="token function">sudo</span> <span class="token function">docker</span> images<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>镜像创建成功后就可以启动容器，启动时记得加上参数“–ipc”。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># fe9c3bd6d102是之前创建成功的镜像的id</span><span class="token function">sudo</span> <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--ipc</span><span class="token operator">=</span>host <span class="token parameter variable">--name</span> master fe9c3bd6d102<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>成功启动容器后可以进入到容器内部查看通信相关信息。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> master /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><font color="red">需要特别说明的是:以下共享内存的代码均来自<a href="https://www.cnblogs.com/52php/p/5861372.html">博客</a>,在此表示感谢。docker镜像创建参考<a href="https://www.cnblogs.com/hailun1987/p/9697236.html">自北极之光的博客</a>。</font></p><ol><li><p><a href="https://www.cnblogs.com/hailun1987/p/9697236.html">https://www.cnblogs.com/hailun1987/p/9697236.html</a></p></li><li><p><a href="https://www.jianshu.com/p/7eb7c7f62bf3">https://www.jianshu.com/p/7eb7c7f62bf3</a></p></li><li><p><a href="https://www.cnblogs.com/52php/p/5861372.html">https://www.cnblogs.com/52php/p/5861372.html</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> ipc </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>autoconf使用</title>
      <link href="/2022/08/01/autoconf-shi-yong/"/>
      <url>/2022/08/01/autoconf-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="autoconf使用"><a href="#autoconf使用" class="headerlink" title="autoconf使用"></a>autoconf使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Autoconf是一个用于生成shell脚本的工具，可自动配置源码包以适应多种类Posix的系统,产生的配置脚本通常叫做configure。Autoconf的目标是为每个用户提供可移植的配置。</p><p>Autoconf解决了一个重要的问题 - 可靠地发现系统特定的构建和运行时信息。为此，GNU项目开发了一套集成实用程序来完成Autoconf的工作：GNU构建系统，其最重要的组件是Autoconf，Automake和Libtool。</p><p>使用以下命令来安装我们需要的组件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> autoconf automake libtool<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><blockquote><p>使用automake,程序开发人员只需要写一些简单的 含有预定义宏的 文件,由autoconf根据一个宏文件生成configure,由automake根据另一个宏文件生成Makefile.in,再使用configure依据Makefile.in来生成一个符合惯例的 Makefile.</p></blockquote><p>使用autoconf的最终目的是生成能够根据不同系统生成Makefile的configure文件，一般情况下我们需要准备如下内容：</p><ol><li>源码</li><li>configure.ac</li><li>Makefile.am</li></ol><p>然后通过如下一系列命令可以生成configure文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aclocal<span class="token punctuation">;</span> autoconf<span class="token punctuation">;</span> autoheadr<span class="token punctuation">;</span>automake --add-missing<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在test目录下有一个main.c文件，其内容如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ha@ha-virtual-machine:~/test$ <span class="token function">ls</span>main.cha@ha-virtual-machine:~/test$ <span class="token function">cat</span> main.c<span class="token comment">#include &lt;stdio.h></span>int <span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        printf<span class="token punctuation">(</span><span class="token string">"This is src<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token builtin class-name">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用autoconf来对其进行编译构建。</p><ol><li><p>使用autoscan扫描当前目录，生成configure.scan文件；可以看到当前目录结构如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ha@ha-virtual-machine:~/test$ autoscanha@ha-virtual-machine:~/test$ <span class="token function">ls</span>autoscan.log  configure.scan  main.cha@ha-virtual-machine:~/test$ <span class="token function">cat</span> configure.scan<span class="token comment">#                                               -*- Autoconf -*-</span><span class="token comment"># Process this file with autoconf to produce a configure script.</span>AC_PREREQ<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2.71</span><span class="token punctuation">]</span><span class="token punctuation">)</span>AC_INIT<span class="token punctuation">(</span><span class="token punctuation">[</span>FULL-PACKAGE-NAME<span class="token punctuation">]</span>, <span class="token punctuation">[</span>VERSION<span class="token punctuation">]</span>, <span class="token punctuation">[</span>BUG-REPORT-ADDRESS<span class="token punctuation">]</span><span class="token punctuation">)</span>AC_CONFIG_SRCDIR<span class="token punctuation">(</span><span class="token punctuation">[</span>main.c<span class="token punctuation">]</span><span class="token punctuation">)</span>AC_CONFIG_HEADERS<span class="token punctuation">(</span><span class="token punctuation">[</span>config.h<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># Checks for programs.</span>AC_PROG_CC<span class="token comment"># Checks for libraries.</span><span class="token comment"># Checks for header files.</span><span class="token comment"># Checks for typedefs, structures, and compiler characteristics.</span><span class="token comment"># Checks for library functions.</span>AC_OUTPUT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>AC_PREREQ声明本文件要求的 autoconf 版本。</p></li><li><p>AC_INIT 宏用来定义软件的名称和版本等信息，本例写成:AC_INIT(Hello, 1.0)</p></li><li><p>这里省略了 BUG-REPORT-ADDRESS 参数，它是可选项，一般写成作者的邮件地址</p></li><li><p>AC_CONFIG_SRCDIR 宏通过侦测所指定的源码文件是否存在，来确定源码目录的有效性。可以选择源码目录中的任何一个文件作为代表, 宏参数中使用 &#96;[ ]’，是为了表明其中的字符串是一个整体。</p></li><li><p>AC_CONFIG_HEADER 宏用于生成 config.h 文件，里面存放 configure 脚本侦测到的信息如果程序需要使用其中的定义，就在源码中加入#include &lt;config.h&gt;</p></li><li><p>其他的一些宏是标准的侦测过程，可以保留不动修改configure.scan为configure.ac，同时修改项目编译相关内容；</p></li></ul></li><li><p>将configure.scan重命名为configure.ac，然后修改其内容，仅需添加AM_INIT_AUTOMAKE(1.0)；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#                                               -*- Autoconf -*-</span><span class="token comment"># Process this file with autoconf to produce a configure script.</span>AC_PREREQ<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2.71</span><span class="token punctuation">]</span><span class="token punctuation">)</span>AC_INIT<span class="token punctuation">(</span><span class="token punctuation">[</span>FULL-PACKAGE-NAME<span class="token punctuation">]</span>, <span class="token punctuation">[</span>VERSION<span class="token punctuation">]</span>, <span class="token punctuation">[</span>BUG-REPORT-ADDRESS<span class="token punctuation">]</span><span class="token punctuation">)</span>AM_INIT_AUTOMAKE<span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span>AC_CONFIG_SRCDIR<span class="token punctuation">(</span><span class="token punctuation">[</span>main.c<span class="token punctuation">]</span><span class="token punctuation">)</span>AC_CONFIG_HEADERS<span class="token punctuation">(</span><span class="token punctuation">[</span>config.h<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># Checks for programs.</span>AC_PROG_CC<span class="token comment"># Checks for libraries.</span><span class="token comment"># Checks for header files.</span><span class="token comment"># Checks for typedefs, structures, and compiler characteristics.</span><span class="token comment"># Checks for library functions.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行aclocal；</p><blockquote><p>autoconf 是 用来生成自动配置软件源代码脚本（configure）的 工具.configure脚本能独立于autoconf运行,且在 运行的 过程中,不需要用户的 干预.<br>要生成configure文件,你必须告诉autoconf如何找到你所用的 宏.方式是 使用aclocal程序来生成你的 aclocal.m4.</p><p>aclocal根据configure.in文件的 内容,自动生成aclocal.m4文件.aclocal是 一个perl 脚本程序,它的 定义是 ：”aclocal - create aclocal.m4 by scanning configure.ac”.</p></blockquote></li><li><p>执行autoconf生成configure；</p><blockquote><p>autoconf从configure.in这个列举编译软件时所需要各种参数的 模板文件中创建configure.<br>autoconf需要GNU m4宏处理器来处理aclocal.m4,生成configure脚本.<br>m4是 一个宏处理器.将输入拷贝到输出,同时将宏展开.宏可以是 内嵌的 ,也可以是 用户定义的 .除了可以展开宏,m4还有一些内建的 函数,用来引用文件,执行命令,整数运算,文本操作,循环等.m4既可以作为编译器的 前端,也可以单独作为一个宏处理器.</p></blockquote></li><li><p>执行autoheader生成config.h.in；</p></li><li><p>将编译规则写入Makfile.am；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">AUTOMAKE_OPTIONS</span><span class="token operator">=</span>foreign<span class="token assign-left variable">bin_PROGRAMS</span><span class="token operator">=</span>test<span class="token assign-left variable">test_SOURCES</span><span class="token operator">=</span>main.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>执行automake生成Makefile.in;</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">automake --add-missing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>automake会根据你写的 Makefile.am来自动生成Makefile.in.<br>Makefile.am中定义的 宏和目标,会指导automake生成指定的 代码.例如,宏bin_PROGRAMS将导致编译和连接的 目标被生成.</p></blockquote></li><li><p>最终当你执行configure时会根据Makefile.in生成Makefile；</p></li></ol><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ol><li><a href="https://blog.csdn.net/qq_22660775/article/details/88975529">https://blog.csdn.net/qq_22660775/article/details/88975529</a></li><li><a href="https://www.laruence.com/2009/11/18/1154.htmls">https://www.laruence.com/2009/11/18/1154.htmls</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> autoconf </tag>
            
            <tag> make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库数据完整性问题（块折断）</title>
      <link href="/2022/07/30/shu-ju-ku-shu-ju-wan-zheng-xing-wen-ti-kuai-zhe-duan/"/>
      <url>/2022/07/30/shu-ju-ku-shu-ju-wan-zheng-xing-wen-ti-kuai-zhe-duan/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库数据完整性问题（块折断）"><a href="#数据库数据完整性问题（块折断）" class="headerlink" title="数据库数据完整性问题（块折断）"></a>数据库数据完整性问题（块折断）</h1><p>数据库保证数据库完整性（解决块折断问题）当前主要有如下三种方式：</p><ol><li><p>操作日志加double write机制（mysql采用该机制）;</p></li><li><p>操作日志加full page write机制（postgresql同时采用这两种机制）；</p></li><li><p>混合方式，既支持操作日志加double write，又支持操作日志加full page write（openguass采用该机制）；</p></li></ol><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="块折断"><a href="#块折断" class="headerlink" title="块折断"></a>块折断</h3><p>数据库在将数据写入磁盘时一般是按page写入磁盘的，而page的大小一般与操作系统的文件块大小不一致。如postgresql默认page大小为8k，而操作系统中文件块大小一般为4k，由于底层是两个块组成的,比如刷第一个操作系统块到磁盘上了,而当刷第二个操作系统块的时候发生了停电等突然停机事故,就会发生块折断（数据块是否折断是根据块的checksum值来检查的），导致写入磁盘中的数据页不完整。</p><h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><blockquote><p>检查点是数据库实例恢复机制的关键，其目的是为了确定某个时间点之前的脏数据已经全部存盘了。目前的通用型关系型数据库都是采用WAL日志的方式来确保提交的事务不会丢失的，而为了提高数据库的性能，减少不必要的IO，所有的数据修改都是在数据库缓冲中完成的。一个数据块被读取到数据库缓冲中之后，对它的修改都是在内存中完成。被修改过的数据块或者数据页被称为脏块（脏页）。这些脏块会被延后写盘，以减少IO开销。</p></blockquote><p>在数据中数据写入中，一般都通过先写日志（操作日志），再写数据的方式进行数据落盘。这样在数据库宕机的时候，可以通过redo（回放操作）来恢复日志。</p><blockquote><p>检查点实际上是一个时间戳，这个时间戳之前的所有脏块都已经写盘，而这个时间戳之后的数据不一定是否存储。基于这个原则，那么做实例恢复的时候，只需要重演检查点之后的WAL日志记录，之前的不需要考虑了。</p></blockquote><blockquote><p>当检查点发生的时候，数据库需要完成几个工作，首先是扫描出数据库缓冲区中的所有脏页，然后把这些脏页都写入数据文件，然后执行fsync来确保操作系统缓冲区中的数据都已经真实的写盘。然后我们就可以标注当前数据库的检查点为最晚的脏块的最后修改时间。</p></blockquote><blockquote><p>检查点是数据库事件，它是指当前数据库dbwr进程将脏块从db buffer写到数据文件的进度，减少实例崩溃后，实例恢复的时间，是实例恢复的起点。</p></blockquote><h3 id="完全检查点"><a href="#完全检查点" class="headerlink" title="完全检查点"></a>完全检查点</h3><p>完全检查点是指检查点事件发送时，将所有脏页写入到磁盘时记录的进度。完全检查点有如下特点：</p><ol><li>若在检查点发生的时候，仍然有大量数据写入，那此时的脏页并不会写入磁盘；</li><li>完全检查点发生的周期一般较长（相对于增量检查点而言），因而完全检查点会等累积了大量的脏数据后才会刷盘；</li><li>当数据在某个检查点内突发时，会导致在该检查点刷盘时需要刷入大量脏数据；</li></ol><h3 id="增量检查点"><a href="#增量检查点" class="headerlink" title="增量检查点"></a>增量检查点</h3><p>增量检查点是相对于完全检查点而言，其发生的周期更短，且每次刷入磁盘的脏页数据不会累积。增量检查点能够减轻数据库写进程将数据刷入磁盘的负担，均衡磁盘的IO操作；同时因为增量检查点更密集，当数据库发生宕机时检查点离宕机的数据点更近，其恢复数据也更快。</p><h2 id="double-write"><a href="#double-write" class="headerlink" title="double_write"></a>double_write</h2><h3 id="innodb的double-write机制"><a href="#innodb的double-write机制" class="headerlink" title="innodb的double_write机制"></a>innodb的double_write机制</h3><h4 id="double-write-流程"><a href="#double-write-流程" class="headerlink" title="double_write 流程"></a>double_write 流程</h4><blockquote><p>doublewrite由两部分组成，一部分为内存中的doublewrite buffer，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。</p><ol><li>当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的doublewrite buffer中</li><li>接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB</li><li>待第二步完成后，再将doublewrite buffer中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖)</li></ol><p>其实际流程如下图：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-I5lnSr32-1653961009324)(..&#x2F;pgsql_image&#x2F;double_write_flow.png)]</p></blockquote><h4 id="double-write恢复过程"><a href="#double-write恢复过程" class="headerlink" title="double_write恢复过程"></a>double_write恢复过程</h4><blockquote><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XsU5vcBg-1653961009327)(..&#x2F;pgsql_image&#x2F;double_write_crash_flow.png)]</p><ol><li>copy过程中，操作系统crash，重启之后，脏页未刷到磁盘，但更早的数据并没有发生损坏，重新写入即可</li><li>write到共享表空间过程中，操作系统crash，重启之后，脏页未刷到磁盘，但更早的数据并没有发生损坏，重新写入即可</li><li>write到独立表空间过程中，操作系统crash，重启之后，发现：<ul><li>数据文件内的页损坏：头尾checksum值不匹配（即出现了partial page write的问题）。从共享表空间中d的doublewrite segment内恢复该页的一个副本到数据文件，再应用redo log；</li><li>若页自身的checksum匹配，但与doublewrite segment中对应页的checksum不匹配，则统一可以通过apply redo log来恢复。）</li></ul></li><li>比较页面的checksum，如果不对的话，直接从共享表空间的double write中找到该页的一个最近的副本，将其复制到表空间文件，再应用redo log，就完成了恢复过程。因为有副本所以也不担心表空间中数据页是否损坏。</li></ol></blockquote><h3 id="openguass的double-write机制"><a href="#openguass的double-write机制" class="headerlink" title="openguass的double write机制"></a>openguass的double write机制</h3><p>openguass的double write机制与innodb类似，数据在写入文件系统之前，首先会写入双写文件。</p><blockquote><p>一般磁盘的最小I&#x2F;O单位为1个扇区（512字节），大部分文件系统的I&#x2F;O单位为8个扇区。数据库最小的I&#x2F;O单位为一个页面（16个扇区），因此如果在写入磁盘过程中发生宕机，可能出现一个页面只有部分数据写入磁盘的情况，会影响当前日志恢复的一致性。为了解决上述问题，openGauss引入了双写文件。所有页面在写入文件系统之前，首先要写入双写文件，并且双写文件以“O_SYNC | O_DIRECT”模式打开，保证同步写入磁盘。因为双写文件是顺序追加的，所以即使采用同步写入磁盘，也不会带来太明显的性能损耗。在数据库恢复时，首先从双写文件中将可能存在的部分写入磁盘的页面进行修复，然后再回放日志进行日志恢复。</p><p>此外也可以采用FPW（full page write，全页写）技术解决部分数据写入磁盘问题：在每次检查点之后，对于某个页面首次修改的日志中记录完整的页面数据。但是为了保证I&#x2F;O性能的稳定性，目前openGauss默认使用增量检查点机制，而该机制与FPW技术无法兼容，所以在openGauss中目前采用双写技术来解决部分数据写入磁盘问题。</p></blockquote><p>openguass使用bgwriter和pagewriter两类线程来负责脏页的磁盘写入工作。</p><ul><li>bgwriter负责脏页持久化的主体工作</li><li>pagewrite负责数据库检查点LSN的推进，将脏页数据拷贝至双写区域并落盘</li></ul><p>openGauss采用一个无锁的全局脏页队列数组来依次记录曾经被用户写操作置脏的那些数据页面。</p><h4 id="pgwriter"><a href="#pgwriter" class="headerlink" title="pgwriter"></a>pgwriter</h4><p>pgwriter的工作流程大致如下：</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TB获取当前脏页队列队首位置head的值<span class="token arrow operator">--></span>从head值下标开始扫描脏页队列<span class="token arrow operator">--></span>达到批量刷页上限后将本批脏页写入双写文件并分发给各个pagewriter线程并行写入文件系统<span class="token arrow operator">--></span>pagewrite主线程等待所有子线程完成文件写操作<span class="token arrow operator">--></span>将当前脏页队列的队首位置head设置为下一个待刷盘的脏页位置<span class="token arrow operator">--></span>loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码流程如下：</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TBckpt_pagewriter_main<span class="token arrow operator">--></span>dw_upgrade_single<span class="token arrow operator">--></span>dw_upgrade_batch<span class="token arrow operator">--></span>dw_upgrade_renable_double_write<span class="token arrow operator">--></span>ckpt_pagewriter_main_thread_loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="openguass的增量检查点机制"><a href="#openguass的增量检查点机制" class="headerlink" title="openguass的增量检查点机制"></a>openguass的增量检查点机制</h3><p>在openguass中，全量检查点时checkpoint线程同一时刻会将BufferPool中所有脏页写入磁盘，完成打点。</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TBcheckpoint<span class="token arrow operator">--></span>BufferPool<span class="token arrow operator">--></span>tableFilecheckpoint<span class="token arrow operator">---></span>controlFile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>而增量检查点时会有专门的PageWriter线程维护一个脏页队列，定期将脏页刷到磁盘，checkpoint根据PageWriter刷页进度进行打点。</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TBPageWriter<span class="token arrow operator">--></span>DirtyPageQueue<span class="token arrow operator">--></span>tableFileDirtyPageQueue<span class="token arrow operator">--></span><span class="token label property">|recovery lsn|</span>checkpointcheckpoint<span class="token arrow operator">---></span>controlFile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="postgresql-double-write社区补丁"><a href="#postgresql-double-write社区补丁" class="headerlink" title="postgresql double_write社区补丁"></a>postgresql double_write社区补丁</h3><blockquote><p>为了优化full_page_write，社区提供了一个patch，它的主要设计是创建两个共享内存块队列，checkpoint专用buffer队列和非checkpoint专用buffer队列，同时关闭full_page_write。当用户DML产生的数据buffer需要刷盘时，并不是立即刷到磁盘，而是先进入double write的buffer队列，当buffer队列满时，则将buffer队列里面的数据首先刷到特别的double write文件，然后再将数据刷到数据库文件。通过这种设计就不需要在checkpoint 之后在对数据页面的第一次写的时候会将整个数据页面写到 xlog 里面。当数据库需要恢复的时候，遍历所有double write文件里面的记录块，找到每个记录块对应的数据库page，然后对这个page进行checksum，如果page损坏，那么直接把记录块里面的内容覆盖到buffer数据。最后把double write文件删除，重新初始化buffer队列。</p></blockquote><p>补丁详情可查看<a href="https://www.postgresql.org/message-id/1962493974.656458.1327703514780.JavaMail.root@zimbra-prod-mbox-4.vmware.com">这里</a>。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-JpmVDDwn-1653961009329)(..&#x2F;pgsql_image&#x2F;pg_double_write_flow.png)]</p><h2 id="full-page-write"><a href="#full-page-write" class="headerlink" title="full_page_write"></a>full_page_write</h2><blockquote><p>在postgresql中，当checkpoint后的一个块第一次变脏后就要整块写入到wal日志中,后续继续修改此块则只把修改的信息写入wal日志中。如果在此过程中发生了停电,则实例启动后会从checkpoint检查点，之后开始进行实例恢复,如果有块折断,则在全页写入的块为基础进行恢复,最后覆盖磁盘上的折断块,所以当每次checkpoint后如果数据有修改都会进行全页写入。这保证了在恢复过程中，接触到一个页面的第一个wal记录包含了整个页面，而不需要从数据文件中读取可能被破坏的页面。</p></blockquote><blockquote><p>打开full_page_write的代价是增加了必须被写入wal的数据量，也就是wal的写放大问题。这样会增加额外的IO和磁盘消耗。</p></blockquote><h2 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h2><p>【开发云】年年都是折扣价，不用四处薅羊毛 <a href="https://dev.csdn.net/activity?utm_source=sale_source&sale_source=Igt9xAFU3H">https://dev.csdn.net/activity?utm_source=sale_source&amp;sale_source=Igt9xAFU3H</a></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li><a href="https://www.modb.pro/db/47042">https://www.modb.pro/db/47042</a></li><li><a href="https://blog.csdn.net/u012954897/article/details/17642595">https://blog.csdn.net/u012954897/article/details/17642595</a></li><li><a href="https://www.cnblogs.com/geaozhang/p/7241744.html">https://www.cnblogs.com/geaozhang/p/7241744.html</a></li><li><a href="https://blog.csdn.net/leonpenn/article/details/73176601">https://blog.csdn.net/leonpenn/article/details/73176601</a></li><li><a href="https://zhuanlan.zhihu.com/p/367742817">https://zhuanlan.zhihu.com/p/367742817</a></li><li><a href="http://mysql.taobao.org/monthly/2015/11/05/">http://mysql.taobao.org/monthly/2015/11/05/</a></li><li><a href="https://blog.csdn.net/Hehuyi_In/article/details/103020182">https://blog.csdn.net/Hehuyi_In/article/details/103020182</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> postgresql </tag>
            
            <tag> 数据完整性 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变长数组（柔性数组）</title>
      <link href="/2022/07/29/bian-chang-shu-zu-rou-xing-shu-zu/"/>
      <url>/2022/07/29/bian-chang-shu-zu-rou-xing-shu-zu/</url>
      
        <content type="html"><![CDATA[<h2 id="变长数组（柔性数组）"><a href="#变长数组（柔性数组）" class="headerlink" title="变长数组（柔性数组）"></a>变长数组（柔性数组）</h2><p>C99支持变长数组，定义时可以不指定数组长度，分配时再根据实际长度进行分配。</p><ul><li>变长数组一般只能放在结构体的最后一个成员，</li><li>在变长数组之前至少得有一个结构体成员</li><li>且一个结构体只能有一个变长数组</li></ul><p>变长数组实际是利用结构体的地址作为起始地址往后面分配内存，这样就可以在实际申请内存的时候按需要的元素个数来进行申请。</p><ul><li>定义1</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">test</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>定义2</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">test</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>定义3</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">FLEXIBLE_ARRAY_MEMBER</span></span><span class="token keyword">struct</span> <span class="token class-name">test</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token keyword">int</span> data<span class="token punctuation">[</span>FLEXIBLE_ARRAY_MEMBER<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般定义2使用的最多，定义3在postgresql中使用，定义1很少用。</p><p><strong>note：变长数组前面的成员不能省略，当然不一定是长度，可以其他没有意义的成员。</strong>。</p><p>使用的时候可以使用如下的方式来申请内存：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">test</span> <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">test</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">test</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10个元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缩短tcp超时时间的方法</title>
      <link href="/2022/07/28/suo-duan-tcp-chao-shi-shi-jian-de-fang-fa/"/>
      <url>/2022/07/28/suo-duan-tcp-chao-shi-shi-jian-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="缩短tcp超时时间的方法"><a href="#缩短tcp超时时间的方法" class="headerlink" title="缩短tcp超时时间的方法"></a>缩短tcp超时时间的方法</h1><p>在tcp链路中，当网络异常时，缩短tcp超时时间一般有如下方法：</p><ul><li>TCP_USER_TIMEOUT(需要内核2.6.37及其以上版本)</li><li>SIOCOUTQ</li><li>tcp_retries2</li><li>应用层keepalive</li></ul><h2 id="TCP-USER-TIMEOUT"><a href="#TCP-USER-TIMEOUT" class="headerlink" title="TCP_USER_TIMEOUT"></a>TCP_USER_TIMEOUT</h2><p>需要内核2.6.37及其以上版本才支持该选项。</p><blockquote><p>TCP_USER_TIMEOUT选项是TCP层的socket选项，选项接受unsigned int类型的值。值为数据包被发送后未接收到ACK确认的最大时长，以毫秒为单位，例如设置为10000时，代表如果发送出去的数据包在十秒内未收到ACK确认，则下一次调用send或者recv，则函数会返回-1，errno设置为ETIMEOUT，代表connection timeout。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> timeout <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token function">setsockopt</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> IPPROTO_TCP<span class="token punctuation">,</span> TCP_USER_TIMEOUT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeout<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span>stderror<span class="token punctuation">,</span> <span class="token string">"set TCP_USER_TIMEOUT option error: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SIOCOUTQ"><a href="#SIOCOUTQ" class="headerlink" title="SIOCOUTQ"></a>SIOCOUTQ</h2><blockquote><p>linux提供了ioctl(fd, SIOCOUTQ, &amp;count)方法来查询一个tcp socket的write buffer是否清空。发送方一般可以用这个方法来判断对端是否收到报文。当底层网卡将缓冲区的数据全部发送成功时，获取的count&#x3D;0.</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ioctl.h></span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sockios.h></span></span> <span class="token keyword">int</span> value<span class="token punctuation">;</span> <span class="token function">ioctl</span><span class="token punctuation">(</span>client_fd<span class="token punctuation">,</span>SIOCOUTQ<span class="token punctuation">,</span><span class="token operator">&amp;</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="tcp-retries2"><a href="#tcp-retries2" class="headerlink" title="tcp_retries2"></a>tcp_retries2</h2><blockquote><p>在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试。默认值为15，根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒).(这个值根据目前的网络设置,可以适当地改小,我的网络内修改为了5)</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>CTL_NET<span class="token punctuation">,</span> NET_IPV4<span class="token punctuation">,</span> NET_IPV4_TCP_RETRIES2<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">long</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sysctl</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>size<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  value <span class="token comment">// It contains current value from /proc/sys/net/ipv4/tcp_retries2</span><span class="token punctuation">&#125;</span>value <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Change value if it needed</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sysctl</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>value<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Value in /proc/sys/net/ipv4/tcp_retries2 changed successfully</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tcp_retries2指定的是tcp重传的次数，其超时时间与RTO的计算有关。RTO最小值默认为200ms，最大为120s，在tcp的重传过程中，以200ms为基础，每次重传超时时间翻倍，但最大只能为120s。</p><p>在linux中tcp_retries2默认为15，因而其超时时间为：(2^9 -1)*0.2 + (16 - 9) * 120s &#x3D; 924.6s.</p><p><font color="red">需要特别留意的是tcp_retries2针对的是系统上的所有链路。</font></p><h2 id="应用层keepalive"><a href="#应用层keepalive" class="headerlink" title="应用层keepalive"></a>应用层keepalive</h2><p>可以在应用层实现keepalive机制，通过主动发送keepalive报文和设置超时时间来检测链路是否异常。</p><p><font color="red">需修改应用层代码，设计实现keepalive。</font></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li><a href="https://stackoverflow.com/questions/5907527/application-control-of-tcp-retransmission-on-linux/5907951#5907951">https://stackoverflow.com/questions/5907527/application-control-of-tcp-retransmission-on-linux/5907951#5907951</a></li><li><a href="https://blog.csdn.net/thwack/article/details/79960935">https://blog.csdn.net/thwack/article/details/79960935</a></li><li><a href="https://developer.aliyun.com/article/840000">https://developer.aliyun.com/article/840000</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> tcp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tcp </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vpp开发指南</title>
      <link href="/2022/07/27/vpp-kai-fa-zhi-nan/"/>
      <url>/2022/07/27/vpp-kai-fa-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h1 id="vpp开发指南"><a href="#vpp开发指南" class="headerlink" title="vpp开发指南"></a>vpp开发指南</h1><p>vpp二次开发一般都是基于vpp框架进行插件开发。具体友包含以下几个方面：</p><ul><li>配置</li><li>插入节点</li><li>收包</li><li>发包</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// sample_config是配置读取函数</span><span class="token comment">// sample是startup.conf文件中的模块名字</span><span class="token function">VLIB_CONFIG_FUNCTION</span> <span class="token punctuation">(</span>sample_config<span class="token punctuation">,</span> <span class="token string">"sample"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读取完配置后可以使用sample_init来进行初始化</span><span class="token function">VLIB_INIT_FUNCTION</span><span class="token punctuation">(</span>sample_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 注册一个名为sample_node的节点</span><span class="token function">VLIB_REGISTER_NODE</span> <span class="token punctuation">(</span>sample_node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// sample_node收到报文后如何处理</span><span class="token function">VLIB_NODE_FN</span> <span class="token punctuation">(</span>sample_node<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">vlib_main_t</span> <span class="token operator">*</span> vm<span class="token punctuation">,</span> <span class="token class-name">vlib_node_runtime_t</span> <span class="token operator">*</span> node<span class="token punctuation">,</span><span class="token class-name">vlib_frame_t</span> <span class="token operator">*</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="收包"><a href="#收包" class="headerlink" title="收包"></a>收包</h2><p>收包插入一个收包节点，组织节点关系即可。</p><ul><li><p>L1</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">vnet_hw_interface_rx_redirect_to_node</span> <span class="token punctuation">(</span><span class="token class-name">vnet_main_t</span> <span class="token operator">*</span>vnm<span class="token punctuation">,</span> u32 hw_if_index<span class="token punctuation">,</span> u32 node_index<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>L2、L3</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ethernet_register_input_type</span> <span class="token punctuation">(</span><span class="token class-name">vlib_main_t</span> <span class="token operator">*</span>vm<span class="token punctuation">,</span> <span class="token class-name">ethernet_type_t</span> type<span class="token punctuation">,</span> u32 node_index<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>L4</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ip4_register_protocol</span> <span class="token punctuation">(</span>u32 protocol<span class="token punctuation">,</span> u32 node_index<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>L5</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">udp_register_dst_port</span> <span class="token punctuation">(</span><span class="token class-name">vlib_main_t</span> <span class="token operator">*</span> vm<span class="token punctuation">,</span> <span class="token class-name">udp_dst_port_t</span> dst_port<span class="token punctuation">,</span> u32 node_index<span class="token punctuation">,</span> u8 is_ip4<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="发包"><a href="#发包" class="headerlink" title="发包"></a>发包</h2><p>发包插入一个发包节点，组织节点关系即可。</p><h2 id="命令下发"><a href="#命令下发" class="headerlink" title="命令下发"></a>命令下发</h2><p>注册cli命令，进而可以在vppctl中对vpp流程进行控制。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">VLIB_CLI_COMMAND</span> <span class="token punctuation">(</span>sample_node<span class="token punctuation">,</span> <span class="token keyword">static</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token string">"sample"</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span>function <span class="token operator">=</span> sample<span class="token punctuation">,</span>  <span class="token punctuation">.</span>short_help <span class="token operator">=</span> <span class="token string">"sample"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="云服务推荐"><a href="#云服务推荐" class="headerlink" title="云服务推荐"></a>云服务推荐</h2><h2 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h2><p>【开发云】年年都是折扣价，不用四处薅羊毛 <a href="https://dev.csdn.net/activity?utm_source=sale_source&sale_source=Igt9xAFU3H">https://dev.csdn.net/activity?utm_source=sale_source&amp;sale_source=Igt9xAFU3H</a></p>]]></content>
      
      
      <categories>
          
          <category> vpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpp </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dpdk_kni_use</title>
      <link href="/2022/07/26/dpdk-kni-use/"/>
      <url>/2022/07/26/dpdk-kni-use/</url>
      
        <content type="html"><![CDATA[<h1 id="dpdk之kni使用"><a href="#dpdk之kni使用" class="headerlink" title="dpdk之kni使用"></a>dpdk之kni使用</h1><h2 id="什么是kni"><a href="#什么是kni" class="headerlink" title="什么是kni"></a>什么是kni</h2><blockquote><p>Kni(Kernel NIC Interface)内核网卡接口，是DPDK允许用户态和内核态交换报文的解决方案，模拟了一个虚拟的网口，提供dpdk的应用程序和linux内核之间通讯。kni接口允许报文从用户态接收后转发到linu协议栈去。 为什么要弄一个kni接口，虽然dpdk的高速转发性能很出色，但是也有自己的一些缺点，比如没有协议栈就是其中一项缺陷，当然也可能当时设计时就将没有将协议栈考虑进去，毕竟协议栈需要将报文转发处理，可能会使处理报文的能力大大降低。</p></blockquote><blockquote><p>当kni向linux发送报文时通过调用netif_rx()将报文送入linux协议栈，这其中需要将dpdk的mbuf转换成skb_buf。</p></blockquote><blockquote><p>当linux向kni端口发送报文时，调用回调函数kni_net_tx()，然后报文经过转换之后发送到端口上。</p></blockquote><h3 id="kni优势"><a href="#kni优势" class="headerlink" title="kni优势"></a>kni优势</h3><ul><li>相较现存的Linux TUN&#x2F;TAP接口更快的速度（消除了系统调用以及copy_to_user()&#x2F;copy_from_user()内存拷贝的消耗）</li><li>允许标准Linux网络工具管理DPDK接口，如ethtool, ifconfig 和 tcpdump</li><li>提供到内核协议栈接口</li></ul><h2 id="kni代码分析"><a href="#kni代码分析" class="headerlink" title="kni代码分析"></a>kni代码分析</h2><p>和igb uio模块一样，kni模块分成内核以及用户态代码，内核模块在编译出来之后为rte_kni.ko，首先插入内核，dpdk提供了一个用户态的例子。首先看下kni内核模块代码,在kni_misc.c中，ko代码入口为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">module_init</span><span class="token punctuation">(</span>kni_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先选择kni的线程模式，分为单线程还是多线程，所谓单线程是指所有的kni端口收发都由一个线程守护，多线程只是每一个kni端口分为由一个线程守护，这部分是在插入模块时带入参数选择。 接着调用注册函数misc_register，将kni注册为一个混杂设备。其中kni_misc结构体里面定义了该混杂设备的一些操作：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">miscdevice</span> kni_misc <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span>minor <span class="token operator">=</span> MISC_DYNAMIC_MINOR<span class="token punctuation">,</span><span class="token punctuation">.</span>name <span class="token operator">=</span> KNI_DEVICE<span class="token punctuation">,</span><span class="token punctuation">.</span>fops <span class="token operator">=</span> <span class="token operator">&amp;</span>kni_fops<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> kni_fops <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>    <span class="token punctuation">.</span>open <span class="token operator">=</span> kni_open<span class="token punctuation">,</span>    <span class="token punctuation">.</span>release <span class="token operator">=</span> kni_release<span class="token punctuation">,</span>    <span class="token punctuation">.</span>unlocked_ioctl <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>kni_ioctl<span class="token punctuation">,</span>    <span class="token punctuation">.</span>compat_ioctl <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>kni_compat_ioctl<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里涉及的主要操作有kni_open，kni_release，以及kni_ioctl，分别对应几个函数。</p><ul><li>kni_open</li></ul><p> kni_open时如果是单线程模式则会创建一个内核线程，并打开dev&#x2F;kni，这个时候在host的dev下能看到kni文件夹</p><ul><li>kni_ioctl</li></ul><p>kni_ioctl函数是与用户态通信的一个接口，主要是kni_ioctl_create函数。</p><p>ret &#x3D; copy_from_user(&amp;dev_info, (void *)ioctl_param,  sizeof(dev_info));这条语句会拷贝从用户态传过来的消息，dev_info主要存放了虚拟kni网口的相关参数，接下来就会根据dev_info中的参数注册一个kni网口ret &#x3D; register_netdev(net_dev);</p><p>这个函数完成创建，这样就虚拟出一个网口出来。其中165行是自己修改的，因为我发现按照文档提供的方法根本不能ping通报文，我将生成kni的mac地址修改成dpdk接管的网口mac即可贯通。原生态代码是随时生成一个mac。</p><ul><li>杂项设备（misc device）</li></ul><p>杂项设备也是在嵌入式系统中用得比较多的一种设备驱动。在 Linux 内核的include&#x2F;linux目录下有Miscdevice.h文件，要把自己定义的misc device从设备定义在这里。其实是因为这些字符设备不符合预先确定的字符设备范畴，所有这些设备采用主编号10 ，一起归于misc device，其实misc_register就是用主标号10调用register_chrdev()的。</p><p>也就是说，misc设备其实也就是特殊的字符设备，可自动生成设备节点。</p><h3 id="dpdk-mbuf与sk-buf转换"><a href="#dpdk-mbuf与sk-buf转换" class="headerlink" title="dpdk mbuf与sk_buf转换"></a>dpdk mbuf与sk_buf转换</h3><p>收包时需调用netif_receive_skb(skb)或netif_rx_ni(skb)通知内核处理包，发包时直接由内核调用ndo_start_xmit发出。</p><ul><li>mbuf-&gt;sk_buf（收包）</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * RX: normal working mode */</span><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token function">kni_net_rx_normal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kni_dev</span> <span class="token operator">*</span>kni<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> ret<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> len<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> i<span class="token punctuation">,</span> num<span class="token punctuation">,</span> num_rq<span class="token punctuation">,</span> num_fq<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">rte_kni_mbuf</span> <span class="token operator">*</span>kva<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">rte_kni_mbuf</span> <span class="token operator">*</span>va<span class="token punctuation">[</span>MBUF_BURST_SZ<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span> data_kva<span class="token punctuation">;</span>     <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev <span class="token operator">=</span> kni<span class="token operator">-></span>net_dev<span class="token punctuation">;</span>     <span class="token comment">/* 每次收包的个数必须为rx_q和free_q的最小值且不超过MBUF_BURST_SZ */</span>     <span class="token comment">/* Get the number of entries in rx_q */</span>    num_rq <span class="token operator">=</span> <span class="token function">kni_fifo_count</span><span class="token punctuation">(</span>kni<span class="token operator">-></span>rx_q<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/* Get the number of free entries in free_q */</span>    num_fq <span class="token operator">=</span> <span class="token function">kni_fifo_free_count</span><span class="token punctuation">(</span>kni<span class="token operator">-></span>free_q<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/* Calculate the number of entries to dequeue in rx_q */</span>    num <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>num_rq<span class="token punctuation">,</span> num_fq<span class="token punctuation">)</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span>MBUF_BURST_SZ<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/* Return if no entry in rx_q and no free entry in free_q */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>     <span class="token comment">/* Burst dequeue from rx_q */</span>    ret <span class="token operator">=</span> <span class="token function">kni_fifo_get</span><span class="token punctuation">(</span>kni<span class="token operator">-></span>rx_q<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>va<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">/* Failing should not happen */</span>     <span class="token comment">/* mbuf转换为skb */</span>    <span class="token comment">/* Transfer received packets to netif */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* mbuf kva */</span>        kva <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>va<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> kni<span class="token operator">-></span>mbuf_va <span class="token operator">+</span> kni<span class="token operator">-></span>mbuf_kva<span class="token punctuation">;</span>        len <span class="token operator">=</span> kva<span class="token operator">-></span>data_len<span class="token punctuation">;</span>        <span class="token comment">/* data kva */</span>        data_kva <span class="token operator">=</span> kva<span class="token operator">-></span>data <span class="token operator">-</span> kni<span class="token operator">-></span>mbuf_va <span class="token operator">+</span> kni<span class="token operator">-></span>mbuf_kva<span class="token punctuation">;</span>         skb <span class="token operator">=</span> <span class="token function">dev_alloc_skb</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>skb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">KNI_ERR</span><span class="token punctuation">(</span><span class="token string">"Out of mem, dropping pkts\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* Update statistics */</span>            kni<span class="token operator">-></span>stats<span class="token punctuation">.</span>rx_dropped<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">/* Align IP on 16B boundary */</span>            <span class="token function">skb_reserve</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token function">skb_put</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">,</span> data_kva<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            skb<span class="token operator">-></span>dev <span class="token operator">=</span> dev<span class="token punctuation">;</span>            skb<span class="token operator">-></span>protocol <span class="token operator">=</span> <span class="token function">eth_type_trans</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>            skb<span class="token operator">-></span>ip_summed <span class="token operator">=</span> CHECKSUM_UNNECESSARY<span class="token punctuation">;</span>             <span class="token comment">/* 发送skb到协议栈 */</span>            <span class="token comment">/* Call netif interface */</span>            <span class="token function">netif_receive_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* Call netif interface */</span>    <span class="token comment">//netif_rx_ni(skb);//dpdk18.11</span>             <span class="token comment">/* Update statistics */</span>            kni<span class="token operator">-></span>stats<span class="token punctuation">.</span>rx_bytes <span class="token operator">+=</span> len<span class="token punctuation">;</span>            kni<span class="token operator">-></span>stats<span class="token punctuation">.</span>rx_packets<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">/* 通知用户空间释放mbuf */</span>    <span class="token comment">/* Burst enqueue mbufs into free_q */</span>    ret <span class="token operator">=</span> <span class="token function">kni_fifo_put</span><span class="token punctuation">(</span>kni<span class="token operator">-></span>free_q<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>va<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> num<span class="token punctuation">)</span>        <span class="token comment">/* Failing should not happen */</span>        <span class="token function">KNI_ERR</span><span class="token punctuation">(</span><span class="token string">"Fail to enqueue entries into free_q\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>sk_buf-&gt;mbuf（发包）</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span><span class="token function">kni_net_tx</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> ret<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">kni_dev</span> <span class="token operator">*</span>kni <span class="token operator">=</span> <span class="token function">netdev_priv</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">rte_kni_mbuf</span> <span class="token operator">*</span>pkt_kva <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">rte_kni_mbuf</span> <span class="token operator">*</span>pkt_va <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>     dev<span class="token operator">-></span>trans_start <span class="token operator">=</span> jiffies<span class="token punctuation">;</span> <span class="token comment">/* save the timestamp */</span>     <span class="token comment">/* Check if the length of skb is less than mbuf size */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token operator">-></span>len <span class="token operator">></span> kni<span class="token operator">-></span>mbuf_size<span class="token punctuation">)</span>        <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>     <span class="token comment">/**     * Check if it has at least one free entry in tx_q and     * one entry in alloc_q.     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">kni_fifo_free_count</span><span class="token punctuation">(</span>kni<span class="token operator">-></span>tx_q<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>            <span class="token function">kni_fifo_count</span><span class="token punctuation">(</span>kni<span class="token operator">-></span>alloc_q<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/**         * If no free entry in tx_q or no entry in alloc_q,         * drops skb and goes out.         */</span>        <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">/* skb转mbuf */</span>    <span class="token comment">/* dequeue a mbuf from alloc_q */</span>    ret <span class="token operator">=</span> <span class="token function">kni_fifo_get</span><span class="token punctuation">(</span>kni<span class="token operator">-></span>alloc_q<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>pkt_va<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">void</span> <span class="token operator">*</span>data_kva<span class="token punctuation">;</span>         pkt_kva <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pkt_va <span class="token operator">-</span> kni<span class="token operator">-></span>mbuf_va <span class="token operator">+</span> kni<span class="token operator">-></span>mbuf_kva<span class="token punctuation">;</span>        data_kva <span class="token operator">=</span> pkt_kva<span class="token operator">-></span>data <span class="token operator">-</span> kni<span class="token operator">-></span>mbuf_va <span class="token operator">+</span> kni<span class="token operator">-></span>mbuf_kva<span class="token punctuation">;</span>         len <span class="token operator">=</span> skb<span class="token operator">-></span>len<span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>data_kva<span class="token punctuation">,</span> skb<span class="token operator">-></span>data<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>len <span class="token operator">&lt;</span> ETH_ZLEN<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">memset</span><span class="token punctuation">(</span>data_kva <span class="token operator">+</span> len<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ETH_ZLEN <span class="token operator">-</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            len <span class="token operator">=</span> ETH_ZLEN<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        pkt_kva<span class="token operator">-></span>pkt_len <span class="token operator">=</span> len<span class="token punctuation">;</span>        pkt_kva<span class="token operator">-></span>data_len <span class="token operator">=</span> len<span class="token punctuation">;</span>         <span class="token comment">/* enqueue mbuf into tx_q */</span>        ret <span class="token operator">=</span> <span class="token function">kni_fifo_put</span><span class="token punctuation">(</span>kni<span class="token operator">-></span>tx_q<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>pkt_va<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">/* Failing should not happen */</span>            <span class="token function">KNI_ERR</span><span class="token punctuation">(</span><span class="token string">"Fail to enqueue mbuf into tx_q\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* Failing should not happen */</span>        <span class="token function">KNI_ERR</span><span class="token punctuation">(</span><span class="token string">"Fail to dequeue mbuf from alloc_q\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">/* Free skb and update statistics */</span>    <span class="token function">dev_kfree_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    kni<span class="token operator">-></span>stats<span class="token punctuation">.</span>tx_bytes <span class="token operator">+=</span> len<span class="token punctuation">;</span>    kni<span class="token operator">-></span>stats<span class="token punctuation">.</span>tx_packets<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> NETDEV_TX_OK<span class="token punctuation">;</span> drop<span class="token operator">:</span>    <span class="token comment">/* Free skb and update statistics */</span>    <span class="token function">dev_kfree_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    kni<span class="token operator">-></span>stats<span class="token punctuation">.</span>tx_dropped<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> NETDEV_TX_OK<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="kni运行"><a href="#kni运行" class="headerlink" title="kni运行"></a>kni运行</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul><li>x86</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> config <span class="token assign-left variable">T</span><span class="token operator">=</span>x86_64-native-linuxapp-gcc <span class="token assign-left variable">EXTRA_CFLAGS</span><span class="token operator">=</span><span class="token string">'-g -Ofast -fPIC -ftls-model=local-dynamic'</span><span class="token function">make</span> <span class="token assign-left variable">T</span><span class="token operator">=</span>x86_64-native-linuxapp-gcc  <span class="token assign-left variable">CONFIG_RTE_KNI_KMOD</span><span class="token operator">=</span>y <span class="token assign-left variable">CONFIG_RTE_EAL_IGB_UIO</span><span class="token operator">=</span>y <span class="token assign-left variable">EXTRA_CFLAGS</span><span class="token operator">=</span><span class="token string">'-g -Ofast -fPIC -ftls-model=local-dynamic'</span> <span class="token function">install</span> <span class="token parameter variable">-j</span> <span class="token number">8</span><span class="token function">make</span> examples <span class="token assign-left variable">T</span><span class="token operator">=</span>x86_64-native-linuxapp-gcc <span class="token assign-left variable">O</span><span class="token operator">=</span>x86_64-native-linuxapp-gcc <span class="token parameter variable">-j16</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kni <span class="token punctuation">[</span>EAL options<span class="token punctuation">]</span> -- <span class="token parameter variable">-p</span> PORTMASK <span class="token parameter variable">--config</span><span class="token operator">=</span><span class="token string">"(port,lcore_rx,lcore_tx[,lcore_kthread,...])[,(port,lcore_rx,lcore_tx[,lcore_kthread,...])]"</span> <span class="token punctuation">[</span>-P<span class="token punctuation">]</span> <span class="token punctuation">[</span>-m<span class="token punctuation">]</span><span class="token parameter variable">-p</span> PORTMASK:十六进制接口掩码<span class="token parameter variable">--config</span><span class="token operator">=</span><span class="token string">"(port,lcore_rx,lcore_tx[,lcore_kthread,...])[,(port,lcore_rx,lcore_tx[,lcore_kthread,...])]"</span><span class="token builtin class-name">:</span>指定对于每个物理网口，接收和发送DPDK线程绑定的核心，以及KNI内核线程绑定的核心-P:可选标志，设置的话意味着混杂模式，以便不区分以太网目的MAC地址，接收所有报文。不设置此选项，仅目的MAC地址等于接口MAC地址的报文被接收-m:可选标志。使能监控模式并更新以太网链路状态。此选项需要启动一个DPDK线程定期检查物理接口链路状态，同步相应的KNI虚拟网口状态。意味着当以太网链路down的时候，KNI虚拟接口将自动禁用，反之，自动启用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># rmmod rte_kni</span><span class="token comment"># insmod kmod/rte_kni.ko</span><span class="token comment"># sudo ./kni -l 0-3 -n 4 -- -P -p 0x3 -m --config="(0,0,1),(1,2,3)"</span><span class="token comment"># -l 0-3 使用0-3核</span><span class="token comment"># -n 4   使用4个核</span><span class="token comment"># -p 0x3 (11)使用两个网口，port 0和port 1</span><span class="token comment"># --config="(0,0,1),(1,2,3)" </span><span class="token comment"># (0,0,1) port 0 使用0核rx，1核tx</span><span class="token comment"># (1,2,3) port 1 使用2核rx，3核tx</span>./kni <span class="token parameter variable">-l</span> <span class="token number">0</span>-1 <span class="token parameter variable">-n</span> <span class="token number">2</span> -- <span class="token parameter variable">-p</span> 0x1 <span class="token parameter variable">-P</span> <span class="token parameter variable">--config</span><span class="token operator">=</span><span class="token string">"(0,0,1)"</span><span class="token function">ifconfig</span> vEth0 <span class="token number">121.168</span>.1.12/24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定位追踪"><a href="#定位追踪" class="headerlink" title="定位追踪"></a>定位追踪</h3><p>在kni_net.c的kni_rx_normal中的382行添加如下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">pr_info</span><span class="token punctuation">(</span><span class="token string">"kni recv a packet\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用dmesg观察输出。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RTE_LOG</span><span class="token punctuation">(</span>INFO<span class="token punctuation">,</span> APP<span class="token punctuation">,</span> <span class="token string">"kni send %lu packets\n"</span><span class="token punctuation">,</span>kni_stats<span class="token punctuation">[</span>port_id<span class="token punctuation">]</span><span class="token punctuation">.</span>tx_packets<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>一端使用pktgen回放报文到kni口，分别使用大包和小包。大包使用GTPU报文或者其他TCP&#x2F;IP报文，小包使用arp报文。</p><ul><li>大包(包长1460)</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./app/x86_64-native-linuxapp-gcc/pktgen <span class="token parameter variable">-c</span> 0xe0000 --socket-mem <span class="token number">1024</span> <span class="token parameter variable">-n</span> <span class="token number">2</span> -- <span class="token parameter variable">-P</span> <span class="token parameter variable">-m</span> <span class="token punctuation">[</span><span class="token number">18</span>:19<span class="token punctuation">]</span>.0 <span class="token parameter variable">-s</span> <span class="token number">0</span>:gtpu.pcap <span class="token parameter variable">-T</span> --crc-strip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>小包（）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./app/x86_64-native-linuxapp-gcc/pktgen <span class="token parameter variable">-c</span> 0xe0000 --socket-mem <span class="token number">1024</span> <span class="token parameter variable">-n</span> <span class="token number">2</span> -- <span class="token parameter variable">-P</span> <span class="token parameter variable">-m</span> <span class="token punctuation">[</span><span class="token number">18</span>:19<span class="token punctuation">]</span>.0 <span class="token parameter variable">-s</span> <span class="token number">0</span>:arp_request.pcap <span class="token parameter variable">-T</span> --crc-strip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>kni端的ip需要根据抓包报文进行修改。</p><p><font color="red">10G网口大包大致可以跑到4Gbps线速，小包10G网口大致可以跑到50Mbps线速。</font></p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ol><li><a href="https://www.cnblogs.com/kb342/p/6033139.html">https://www.cnblogs.com/kb342/p/6033139.html</a></li><li><a href="https://blog.csdn.net/u013216061/article/details/72511653">https://blog.csdn.net/u013216061/article/details/72511653</a></li><li><a href="https://www.freesion.com/article/148821991/">https://www.freesion.com/article/148821991/</a></li><li><a href="https://blog.csdn.net/whenloce/article/details/94591357">https://blog.csdn.net/whenloce/article/details/94591357</a></li><li><a href="https://blog.csdn.net/nanhangfengshuai/article/details/50533230">https://blog.csdn.net/nanhangfengshuai/article/details/50533230</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> dpdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> dpdk </tag>
            
            <tag> kni </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
